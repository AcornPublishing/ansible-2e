[[custom_modules]]
== Custom Modules

Sometimes you want to perform a task that is too complex for the +command+ or +shell+ modules, and there is no existing module that does what you want. In that case, you might want to write your own module.((("modules", "custom", seealso="custom modules")))((("custom modules", id="ix_cusmod")))

In the past, I've written custom modules to retrieve my public IP
address when I'm behind a network address translation (NAT) getaway, and to initialize the databases in an OpenStack
deployment. I've thought about writing a custom module for generating
self-signed TLS certificates, though I've never gotten around to it.

Another common use for custom modules is interacting with a third-party service over a REST API. For example, GitHub offers what it calls Releases, which let you attach binary assets to repositories, and these are exposed via GitHub's API.  If your deployment requires you to download a binary asset attached to a private GitHub repository, this would be a good candidate for implementing inside a custom module.

=== Example: Checking That We Can Reach a Remote Server

Let's say we want to check that we can connect to a remote server on a
particular port. If we can't, we want Ansible to treat that as an error and stop running the play.

[NOTE]
====
The custom module we will develop in this chapter is basically a simpler version of the +wait_for+ module.
====

=== Using the Script Module Instead of Writing Your Own

Recall in <<script_custom_python>> how we used the +script+ module to execute custom scripts on remote hosts.((("custom modules", "using script module instead of writing your own")))((("script module", "using instead of writing your own module"))) Sometimes it's simpler to just use the +script+ module rather than write a full-blown Ansible module.


I like putting these types of scripts in a _scripts_ folder along with my playbooks. For example, we could create a script file called
_playbooks/scripts/can_reach.sh_  that accepts as arguments the name of a host, the port to connect to, and ((("can_reach script (example)")))how long it should try to connect before timing out:

----
can_reach.sh www.example.com 80 1
----

We can create a script as shown in <<CAN_REACH>>.

[[CAN_REACH]]
.can_reach.sh
====
[source,bash]
----
#!/bin/bash
host=$1
port=$2
timeout=$3

nc -z -w $timeout $host $port

----
====

We can then invoke this:
[source,yaml+jinja]
----
- name: run my custom script
  script: scripts/can_reach.sh www.example.com 80 1
----

Keep in mind that your script will execute on the remote hosts, just like Ansible modules do. Therefore, any programs your script requires must have been installed previously on the remote hosts. For example,
you can write your script in Ruby, as long as Ruby has been installed on the remote hosts, and the first line of the script invokes the Ruby interpreter, such as the following:

----
#!/usr/bin/ruby
----

=== can_reach as a Module

Next, let's implement +can_reach+ as a proper Ansible module,((("custom modules", "example, checking if can reach remote server"))) which we will be able to invoke like this:
[source,yaml+jinja]
----
- name: check if host can reach the database server
  can_reach: host=db.example.com port=5432 timeout=1

----

This checks whether the host can make a TCP connection to _db.example.com_ on port 5432. It will time out after one second if it fails to make a connection.

We'll use this example throughout the rest of this chapter.


=== Where to Put Custom Modules

Ansible will look in the _library_ directory relative to the playbook. ((("custom modules", "where to store")))((("modules", "custom", "where to store")))((("Library directory, custom modules in")))((("playbooks/library/", primary-sortas="playbooks/library")))In our example, we put our playbooks in the _playbooks_ directory, so we will put our custom module at _playbooks/library/can_reach_.

=== How Ansible Invokes Modules

Before we implement the module, let's go over how ((("custom modules", "how Ansible invokes modules", id="ix_cusmodinv")))((("modules", "how Ansible invokes", id="ix_modinv")))Ansible invokes them.
Ansible will do the following:

. Generate a standalone Python script with the arguments (Python modules only)
. Copy the module to the host
. Create an arguments file on the host (non-Python modules only)
. Invoke the module on the host, passing the arguments file as an argument
. Parse the standard output of the module

Let's look at each of these steps in more detail.

==== Generate a Standalone Python Script with the Arguments pass:[<span class="keep-together">(Python Only)</span>]

If the module is written in Python and uses the helper code that Ansible provides (described later), then Ansible will generate a self-contained Python script that injects helper code, as well as the module arguments.((("arguments script (Python modules)")))((("modules", "how Ansible invokes", "generating Python script with module arguments")))((("Python", "script with module arguments, for Python modules")))


==== Copy the Module to the Host

Ansible will copy the generated Python script (for Python-based modules) or the local file _playbooks/library/can_reach_ (for non-Python-based modules) to a temporary directory on the remote host.((("modules", "how Ansible invokes", "copying the module to the host"))) If you are accessing the remote host as the `ubuntu` user, Ansible will copy the file to a path that looks like the following:

_/home/ubuntu/.ansible/tmp/ansible-tmp-1412459504.14-47728545618200/can_reach_

==== Create an Arguments File on the Host (Non-Python Only)

If the module is not written in Python, Ansible will create a file on the remote host with a ((("modules", "how Ansible invokes", "creating arguments file on host for non-Python modules")))((("arguments file (non-Python modules)")))name like this:

_/home/ubuntu/.ansible/tmp/ansible-tmp-1412459504.14-47728545618200/arguments_

[role="pagebreak-before"]
If we invoke the module like this:
[source,yaml+jinja]
----
- name: check if host can reach the database server
  can_reach: host=db.example.com port=5432 timeout=1
----

then the arguments file will have the following content:

----
host=db.example.com port=5432 timeout=1
----


We can tell Ansible to generate the arguments file for the module as JSON, by adding the ((("JSON", "arguments file for module, generating as")))following line to _playbooks/library/can_reach_:
[source,bash]
----
# WANT_JSON
----

If our module is configured for JSON input, the arguments file will look like this:
[source,json]
----
{"host": "www.example.com", "port": "80", "timeout": "1"}
----

==== Invoke the Module

Ansible will call the module and pass the arguments file as arguments.((("modules", "how Ansible invokes", "invoking the module"))) If it's a Python-based module, Ansible executes the equivalent of the following (with _/path/to/_ replaced by the actual path):

----
/path/to/can_reach
----

If it's a non-Python-based module, Ansible will look at the first line of the
module to determine the interpreter and execute the equivalent of this:

----
/path/to/interpreter /path/to/can_reach /path/to/arguments
----


Assuming the +can_reach+ module is implemented as a Bash script and starts with this:

----
#!/bin/bash
----

then Ansible will do something like this:

----
/bin/bash /path/to/can_reach /path/to/arguments
----


But even this isn't strictly true. What Ansible actually does is the following:

----
/bin/sh -c 'LANG=en_US.UTF-8 LC_CTYPE=en_US.UTF-8 /bin/bash /path/to/can_reach \
/path/to/arguments; rm -rf /path/to/ >/dev/null 2>&1'
----

You can see the exact command that Ansible invokes by passing +-vvv+ to
+ansible-playbook+.((("modules", "how Ansible invokes", startref="ix_modinv")))((("custom modules", "how Ansible invokes modules", startref="ix_cusmodinv")))((("ansible-playbook -vvv command")))


=== Expected Outputs

Ansible expects modules to output JSON. ((("JSON", "expected module outputs")))((("modules", "expected outputs")))((("custom modules", "expected outputs")))For example:

----
{'changed': false, 'failed': true, 'msg': 'could not reach the host'}
----


[NOTE]
====
Prior to version 1.8, Ansible supported a shorthand output format, also known as
_baby JSON_, that looked like +key=value+. ((("baby JSON")))Ansible dropped support for this format
in 1.8.
As you'll see later, if you write your modules in Python, Ansible provides
helper methods that make it easy to generate JSON output.
====

==== Output Variables that Ansible Expects

Your module can return whatever variables you like, but Ansible has special
treatment for certain returned variables.((("modules", "expected outputs", "output variables")))((("custom modules", "expected outputs", "output variables")))

===== changed

All Ansible modules should return a +changed+ variable.((("output variables", "changed")))((("changed variable"))) The +changed+ variable is a Boolean that indicates whether the module execution caused the host to change state. When Ansible runs, it will show in the output whether a state change has happened. If a task has a +notify+ clause to notify a handler, the notification will fire only if +changed+ is +true+.

===== failed

If the module fails to complete, it should return +failed=true+.((("failed variable")))((("output variables", "failed"))) Ansible will treat this task execution as a failure and will not run any further tasks against the host that failed, unless the task has an +ignore_errors+ or +failed_when+ clause.((("ignore_errors clause")))((("failed_when clause")))

If the module succeeds, you can either return +failed=false+ or you can simply leave out the variable.

===== msg

Use the +msg+ variable to add a descriptive message that describes the reason that a module failed.((("msg variable")))((("output variables", "msg")))

If a task fails, and the module returns a +msg+ variable, then Ansible will output that variable slightly differently than it does the other variables. For example, if a module returns the following:
[source,json]
----
{"failed": true, "msg": "could not reach www.example.com:81"}
----

then Ansible will output the following lines when executing this task:

----
failed: [vagrant1] => {"failed": true}
msg: could not reach www.example.com:81
----


=== Implementing Modules in Python

If you implement your custom module in Python, Ansible provides
the +AnsibleModule+ Python class that makes it easier ((("AnsibleModule class")))((("custom modules", "implementing in Python", id="ix_cusmodPy")))((("Python", "implementing custom modules in", id="ix_Pycusmod")))to do the following:

* Parse the inputs
* Return outputs in JSON format
* Invoke external programs

In fact, when writing a Python module, Ansible will inject the arguments
directly into the generated Python file rather than require you to parse a
separate arguments file. We'll discuss how that works later in this chapter.

We'll create our module in Python by creating a _can_reach_ file. I'll start with the implementation and then break it down (see <<can-reach>>).

[[can-reach]]
.can_reach
====
[source,python]
----
#!/usr/bin/python
from ansible.module_utils.basic import AnsibleModule <1>

def can_reach(module, host, port, timeout):
    nc_path = module.get_bin_path('nc', required=True) <2>
    args = [nc_path, "-z", "-w", str(timeout),
            host, str(port)]
    (rc, stdout, stderr) = module.run_command(args) <3>
    return rc == 0

def main():
    module = AnsibleModule( <4>
        argument_spec=dict( <5>
            host=dict(required=True), <6>
            port=dict(required=True, type='int'),
            timeout=dict(required=False, type='int', default=3) <7>
        ),
        supports_check_mode=True <8>
    )

    # In check mode, we take no action
    # Since this module never changes system state, we just
    # return changed=False
    if module.check_mode: <9>
        module.exit_json(changed=False) <10>

    host = module.params['host'] <11>
    port = module.params['port']
    timeout = module.params['timeout']

    if can_reach(module, host, port, timeout):
        module.exit_json(changed=False)
    else:
        msg = "Could not reach %s:%s" % (host, port)
        module.fail_json(msg=msg) <12>

if __name__ == "__main__":
    main()

----
====


<1> Imports the +AnsibleModule+ helper class
<2> Gets the path of an external program
<3> Invokes an external program
<4> Instantiates the +AnsibleModule+ helper class
<5> Specifies the permitted set of arguments
<6> A required argument
<7> An optional argument with a default value
<8> Specifies that this module supports check mode
<9> Tests whether the module is running in check mode
<10> Exits successfully, passing a return value
<11> Extracts an argument
<12> Exits with failure, passing an error message


==== Parsing Arguments

It's easier to understand the way +AnsibleModule+ handles argument parsing by looking at an example.((("custom modules", "implementing in Python", "parsing arguments"))) Recall that our module is invoked like this:
[source,json]
----
- name: check if host can reach the database server
  can_reach: host=db.example.com port=5432 timeout=1

----

Let's assume that the +host+ and +port+ parameters are required, and +timeout+ is an optional parameter with a default value of 3 seconds.


You instantiate an +AnsibleModule+ object by passing it an +argument_spec+, which is a dictionary in which the keys are parameter names and the values are dictionaries that contain information about the parameters.((("argument_spec")))
[source,python]
----
    module = AnsibleModule(
        argument_spec=dict(
            ...
----

In our example, we declare a required argument named +host+. Ansible will report an error if this argument isn't passed to the module when we use it in a task:
[source,python]
----
            host=dict(required=True),
----


The variable named +timeout+ is optional. Ansible assumes that arguments are strings unless specified otherwise. Our +timeout+ variable is an integer, so we specify the type as +int+ so that Ansible will automatically convert it into a Python number. If +timeout+ is not specified, the module will assume it has a value of 3:
[source,python]
----
            timeout=dict(required=False, type='int', default=3)
----

The +AnsibleModule+ constructor takes arguments other than +argument_spec+. In the preceding example, we added this argument:
[source,python]
----
    supports_check_mode = True
----

This indicates that our module supports check mode. We'll explain that a little later in this chapter.

////

TBD: mutually_exclusive
required_together
required_one_of
add_file_common_args
////

==== Accessing Parameters

Once you've declared an +AnsibleModule+ object, you can access the values of the arguments through the +params+ dictionary,((("params dictionary")))((("custom modules", "implementing in Python", "accessing parameters"))) like this:
[source,python]
----
module = AnsibleModule(...)

host = module.params["host"]
port = module.params["port"]
timeout = module.params["timeout"]
----


==== Importing the AnsibleModule Helper Class

Starting with Ansible 2.1.0, Ansible deploys a module to the host by sending a
ZIP file containing the module file along with the imported helper files.((("custom modules", "implementing in Python", "importing AnsibleModule helper class")))((("AnsibleModule class", "importing"))) One
consequence of this it that you can now explicitly import classes, such as the following:

[source,python]
----
from ansible.module_utils.basic import AnsibleModule
----

Prior to Ansible 2.1.0, the +import+ statement in an Ansible module was really a
pseudo import statement.((("import statements"))) In these earlier versions, Ansible copied only a single
Python file to the remote host to execute it.  Ansible simulated the behavior of
a traditional Python import by including the imported code directly into the
generated Python file (similar to how an +#include+ statement works in C or
C\+\+). Because these did not behave like a traditional Python import, if you
explicitly imported a class, the Ansible pass:[<span class="keep-together">module</span>] debugging scripts would not work
properly.  You had to use a wildcard import, and put the import at the end
of the file, just before invoking the main function:

[source,python]
----
...
from ansible.module_utils.basic import *
if __name__ == "__main__":
    main()
----

==== Argument Options

////
lib/ansible/module_utils/basic.py
////

For each argument to an Ansible module, you can ((("arguments (module)", "options for", id="ix_argopt")))((("custom modules", "implementing in Python", "argument options", id="ix_cusmodPyargop")))specify several options, as listed in <<argoption_table>>.

[[argoption_table]]
.Argument options
[options="header"]
|===========================================================================================
|Option   | Description
|required | If +true+, argument is required
|default  | Default value if argument is not required
|choices  | A list of possible values for the argument
|aliases  | Other names you can use as an alias for this argument
|type     | Argument type. Allowed values: `'str'`, `'list'`, `'dict'`, `'bool'`, `'int'`, `'float'`
|===========================================================================================

===== required

The +required+ option is the only option that you should always specify.((("required option"))) If it is +true+, Ansible will return an error if the user fails to specify the argument.

In our +can_reach+ module example, +host+ and +port+ are required, and +timeout+ is not required.

===== default

For arguments that have +required=False+ set, you should generally specify a default value for that option.((("default option"))) In our example:
[source,python]
----
timeout=dict(required=False, type='int', default=3)
----


If the user invokes the module like this:
[source,yaml+jinja]
----
can_reach: host=www.example.com port=443
----

then +module.params["timeout"]+ will contain the value +3+.

[role="pagebreak-before"]
===== choices

The +choices+ option allows you to restrict the allowed arguments to a
predefined list.((("choices option")))

Consider the +distros+ argument in the ((("distros argument")))following example:
[source,python]
----
distro=dict(required=True, choices=['ubuntu', 'centos', 'fedora'])
----

If the user were to pass an argument that was not in the list—for example:

----
distro=suse
----

this would cause Ansible to throw an error.


===== aliases

The +aliases+ option allows you ((("aliases option")))to use different names to refer to the same argument.((("apt module", "package argument")))((("package argument"))) For example, consider the +package+ argument in the +apt+ module:
[source,python]
----
module = AnsibleModule(
    argument_spec=dict(
        ...
        package = dict(default=None, aliases=['pkg', 'name'], type='list'),
    )
)
----

Since `pkg` and `name` are aliases for the `package` argument, these invocations are all equivalent: 
[source,yaml+jinja]
----
- apt: package=vim
- apt: name=vim
- apt: pkg=vim
----

===== type

////
    lib/ansible/module_utils/basic.py

_check-argument_types
////

////
TODO: Confirm the default is string
////
The +type+ option enables you to specify the type of an argument.((("type option"))) By default, Ansible assumes all arguments are strings.

However, you can specify a type for the argument, and Ansible will convert the argument to the desired type.((("int type")))((("float type")))((("bool type")))((("dict type")))((("lists", "list type")))((("strings", "str type"))) The types supported are as follows:

* +str+
* +list+
* +dict+
* +bool+
* +int+
* +float+

In our example, we specified the +port+ argument as +int+:
[source,python]
----
port=dict(required=True, type='int'),
----

When we access it from the +params+ dictionary,((("params dictionary"))) like this:
[source,python]
----
port = module.params['port']
----

the value of the +port+ variable will be an integer. If we had not specified the type as +int+ when declaring the +port+ variable, the +module.params[\'port\']+ value would have been a string instead of an integer.

Lists are comma-delimited.((("lists", "list module parameter"))) For example, if you have a module named +foo+ with a list parameter named +colors+:
[source,python]
----
colors=dict(required=True, type='list')
----

then you pass a +list+ like this:
[source,json]
----
foo: colors=red,green,blue
----


For dictionaries, you can either use +key=value+ pairs, delimited by commas, or you can use JSON inline.((("dictionaries", "dict module parameter")))

For example, if you have a module named +bar+, with a +dict+ parameter named +tags+:
[source,python]
----
tags=dict(required=False, type='dict', default={})
----

then you can pass the argument like this:
[source,yaml+jinja]
----
- bar: tags=env=staging,function=web
----

Or you can pass the argument like this:
[source,yaml+jinja]
----
- bar: tags={"env": "staging", "function": "web"}
----

The official Ansible documentation uses the term _complex args_ to refer to lists and dictionaries that are passed to modules as arguments. See <<COMPLEX_ARGS>> for how to pass these types of arguments in playbooks.((("complex arguments")))((("arguments (module)", "options for", startref="ix_argopt")))((("custom modules", "implementing in Python", "argument options", startref="ix_cusmodPyargop")))

==== AnsibleModule Initializer Parameters

The +AnsibleModule+ initializer method takes various arguments, listed in <<ansiblemod_init_args>>.((("initializer method (AnsibleModule), parameters", id="ix_initAM")))((("custom modules", "implementing in Python", "AnsibleModule initializer method parameters", id="ix_cusmodPyAMinit")))((("AnsibleModule class", "initializer method parameters", id="ix_AnsModinit"))) The only required argument is +argument_spec+.

[[ansiblemod_init_args]]
.AnsibleModule initializer arguments
[options="header"]
|============================================================================================
|Parameter               | Default | Description
|argument_spec           | (_None_)  | Dictionary that contains information about arguments
|bypass_checks           | False   | If true, don't check any of the parameter constraints
|no_log                  | False   | If true, don't log the behavior of this module
|check_invalid_arguments | True    | If true, return error if user passed an unknown argument
|mutually_exclusive      | (_None_)    | List of mutually exclusive arguments
|required_together       | (_None_)    | List of arguments that must appear together
|required_one_of         | (_None_)    | List of arguments where at least one must be present
|add_file_common_args    | False   | Supports the arguments of the +file+ module
|supports_check_mode     | False   | If true, indicates module supports check mode
|============================================================================================

===== argument_spec

This is a dictionary that contains the descriptions of the allowed arguments for
the module, as described in the previous section.((("argument_spec")))

===== no_log

When Ansible executes a module on a host, the module will log output to the syslog,
which on Ubuntu is at _/var/log/syslog_.((("logging from module execution, disabling")))((("no_log argument")))

The logging output looks like this:

----
Sep 28 02:31:47 vagrant-ubuntu-trusty-64 ansible-ping: Invoked with data=None
Sep 28 02:32:18 vagrant-ubuntu-trusty-64 ansible-apt: Invoked with dpkg_options=
force-confdef,force-confold upgrade=None force=False name=nginx package=['nginx'
] purge=False state=installed update_cache=True default_release=None install_rec
ommends=True deb=None cache_valid_time=None Sep 28 02:33:01 vagrant-ubuntu-trust
y-64 ansible-file: Invoked with src=None
original_basename=None directory_mode=None force=False remote_src=None selevel=N
one seuser=None recurse=False serole=None content=None delimiter=None state=dire
ctory diff_peek=None mode=None regexp=None owner=None group=None path=/etc/nginx
/ssl backup=None validate=None setype=None
Sep 28 02:33:01 vagrant-ubuntu-trusty-64 ansible-copy: Invoked with src=/home/va
grant/.ansible/tmp/ansible-tmp-1411871581.19-43362494744716/source directory_mod
e=None force=True remote_src=None dest=/etc/nginx/ssl/nginx.key selevel=None seu
ser=None serole=None group=None content=NOT_LOGGING_PARAMETER setype=None origin
al_basename=nginx.key delimiter=None mode=0600 owner=root regexp=None validate=N
one backup=False
Sep 28 02:33:01 vagrant-ubuntu-trusty-64 ansible-copy: Invoked with src=/home/va
grant/.ansible/tmp/ansible-tmp-1411871581.31-95111161791436/source directory_mod
e=None force=True remote_src=None dest=/etc/nginx/ssl/nginx.crt selevel=None seu
ser=None serole=None group=None content=NOT_LOGGING_PARAMETER setype=None origin
al_basename=nginx.crt delimiter=None mode=None owner=None regexp=None validate=N
one backup=False
----

If a module accepts sensitive information as an argument, you might want to disable this logging. To configure a module so that it does not write to syslog, pass the
+no_log=True+ parameter to the +AnsibleModule+ initializer.

===== check_invalid_arguments

By default, Ansible will verify that all of the arguments that a user passed to
a module are legal arguments.((("check_invalid_arguments"))) You can disable this check by passing the
+check_invalid_&#x200b;argu&#x2060;ments=False+ parameter to the +AnsibleModule+ initializer.

===== mutually_exclusive

The +mutually_exclusive+ parameter is a list of arguments that cannot be specified during the same module invocation.((("mutually_exclusive parameter"))) For example, the +lineinfile+ module allows you to add a line to a file. You can use the +insertbefore+ argument to specify which line it should appear before, or the +insertafter+ argument to specify which line it should appear after, but you can't specify both.

Therefore, this module specifies that the two arguments are mutually exclusive, like this:
[source,python]
----
mutually_exclusive=[['insertbefore', 'insertafter']]
----


===== required_one_of

The +required_one_of+ parameter expects a list of arguments with at least one that must be passed to the module.((("required_one_of parameter"))) For example, the +pip+ module, which is used for installing Python packages, can take either the name of a package or the name of a requirements file that contains a list of packages. The module specifies that one of these arguments is required like this: 
[source,python]
----
required_one_of=[['name', 'requirements']]
----



===== add_file_common_args

Many modules create or modify a file.((("add_file_common_args"))) A user will often want to set some attributes on the resulting file, such as the owner, group, and file permissions.


You could invoke the +file+ module to set these parameters,((("file module"))) like
this:
[source,yaml+jinja]
----
- name: download a file
  get_url: url=http://www.example.com/myfile.dat dest=/tmp/myfile.dat

- name: set the permissions
  file: path=/tmp/myfile.dat owner=ubuntu mode=0600
----


As a shortcut, Ansible allows you to specify that a module will accept all of the same arguments as the +file+ module, so you can simply set the file attributes by passing the relevant arguments to the module that created or modified the file. For example:

----
- name: download a file
  get_url: url=http://www.example.com/myfile.dat dest=/tmp/myfile.dat \
  owner=ubuntu mode=0600
----

To specify that a module should support these arguments:
[source,python]
----
add_file_common_args=True
----

////
 lib/ansible/module_utils/basic.py
line 667
////

The +AnsibleModule+ module provides helper methods for working
with these arguments.

The +load_file_common_arguments+ method takes the parameters dictionary as an
argument and returns a parameters dictionary that contains all of the arguments
that relate to setting file attributes.((("load_file_common_arguments method")))

The +set_fs_attributes_if_different+ method takes a file parameters dictionary
and a Boolean indicating whether a host state change has occurred yet.((("set_fs_attributes_if_different method"))) The method
sets the file attributes as a side effect and returns +true+ if there was a host
state change (either the initial argument was true, or it made a change to the
file as part of the side effect).


If you are using the common file arguments, do not specify the arguments explicitly. To
get access to these attributes in your code, use the helper methods to extract
the arguments and set the file attributes, like this:
[source,python]
----
module = AnsibleModule(
    argument_spec=dict(
        dest=dict(required=True),
        ...
    ),
    add_file_common_args=True
)

# "changed" is True if module caused host to change state
changed = do_module_stuff(param)

file_args = module.load_file_common_arguments(module.params)

changed = module.set_fs_attributes_if_different(file_args, changed)
module.exit_json(changed=changed, ...)
----

[NOTE]
====
Ansible assumes your module has an argument named +path+ or +dest+, which
contains the path to the file.((("paths", "path argument")))((("dest argument")))
====


===== bypass_checks

Before an Ansible module executes, it first checks that all of the argument
constraints are satisfied, and returns an error if they aren't.((("bypass_checks parameter"))) These include the following:

[role="pagebreak-before"]
* No mutually exclusive arguments are present.
* Arguments marked with the +required+ option are present.
* Arguments restricted by the +choices+ option have the expected values.
* Arguments that specify a +type+ have values that are consistent with the +type+.
* Arguments marked as +required_together+ appear together.
* At least one argument in the list of +required_one_of+ is present.

You can disable all of these checks by setting +bypass_checks=True+.((("initializer method (AnsibleModule), parameters", startref="ix_initAM")))((("custom modules", "implementing in Python", "AnsibleModule initializer method parameters", startref="ix_cusmodPyAMinit")))((("AnsibleModule class", "initializer method parameters", startref="ix_AnsModinit"))) 


==== Returning Success or Failure

Use the +exit_json+ method to return success.((("success or failure, returning from module execution")))((("AnsibleModule class", "exit_json method")))((("exit_json method (AnsibleModule)")))((("custom modules", "implementing in Python", "returning success or failure")))((("changed variable", "returning as exit_json method argument"))) You should always return +changed+ as an argument, and it's good practice to return +msg+ with a meaningful message:
[source,python]
----
module = AnsibleModule(...)
...
module.exit_json(changed=False, msg="meaningful message goes here")
----

Use the +fail_json+ method to indicate failure. ((("AnsibleModule class", "fail_json method")))((("fail_json method (AnsibleModule)")))You should always return a +msg+ parameter((("msg variable", "returning in fail_json method parameter"))) to explain to the user the reason for the failure:
[source,python]
----
module = AnsibleModule(...)
...
module.fail_json(msg="Out of disk space")
----

==== Invoking External Commands

The +AnsibleModule+ class provides the +run_command+ convenience method for calling an external program, which wraps the native Python +subprocess+ module.((("custom modules", "implementing in Python", "invoking external commands")))((("commands", "external, invoking with custom module"))) It accepts the arguments listed in <<runcommand_args>>.((("run_command method arguments")))

[[runcommand_args]]
.run_command arguments
[options="header"]
|==================================================================================================================================================
|Argument         |Type                      |Default | Description
|args (default)   |String or list of strings | (_None_) | The command to be executed (see the following section)
|check_rc         |Boolean                   | False  | If +true+, will call +fail_json+ if command returns a nonzero value
|close_fds        |Boolean                   | True   | Passes as +close_fds+ argument to +subprocess.Popen+
|executable       |String (path to program)  | (_None_)   | Passes as +executable+ argument to +subprocess.Popen+
|data             |String                    | (_None_)   | Send to +stdin+ if child process
|binary_data      |Boolean                   | False  | If +false+ and +data+ is present, Ansible will send a newline to +stdin+ after sending +data+
|path_prefix      |String (list of paths)    | (_None_)   | Colon-delimited list of paths to prepend to +PATH+ environment variable
|cwd              |String (directory path)   | (_None_)   | If specified, Ansible will change to this directory before executing
|use_unsafe_shell |Boolean                   | False  | See the following section
|==================================================================================================================================================


If +args+ is passed as a list, as shown in <<ARGS_AS_LIST>>, then((("args variable", "passed as list")))((("subprocess.Popen"))) Ansible will invoke pass:[<span class="keep-together"><code>subprocess.Popen</code></span>] with +shell=False+.

[[ARGS_AS_LIST]]
.Passing args as a list
====
[source,python]
----
module = AnsibleModule(...)
...
module.run_command(['/usr/local/bin/myprog', '-i', 'myarg'])

----
====


If +args+ is passed as a string, as shown in <<ARGS_AS_STRING>>, then the behavior depends ((("args variable", "passed as string")))on the value of +use_unsafe_shell+.((("Python", "subprocess.Popen class")))((("use_unsafe_shell"))) If +use_unsafe_shell+ is +false+, Ansible will split +args+ into a list and invoke +subprocess.Popen+ with +shell=False+. If +use_unsafe_shell+ is +true+, Ansible will pass +args+ as a string to +subprocess.Popen+ with +shell=True+.footnote:[For more on the Python standard library +subprocess.Popen+ class, see its http://bit.ly/1F72tiU[online documentation].]

[[ARGS_AS_STRING]]
.Passing args as a string
====
[source,python]
----
module = AnsibleModule(...)
...
module.run_command('/usr/local/bin/myprog -i myarg')

----
====

==== Check Mode (Dry Run)

Ansible supports something called _check mode_, which is enabled when passing the +-C+ or +--check+ flag to +ansible-playbook+. ((("check mode")))((("dry run mode")))((("custom modules", "implementing in Python", "check mode")))It is similar to the _dry run_ mode supported by many other tools.((("ansible-playbook -C or --check command")))

When Ansible runs a playbook in check mode, it will not make any changes to the hosts when it runs. Instead, it will simply report whether each task would have changed the host, returned successfully without making a change, or returned an error.

[TIP]
====
Modules must be explicitly configured to support check mode. If you're going to
write your own module, I recommend you support check mode so that your module is
a good Ansible citizen.
====

To tell Ansible that your module supports ((("supports_check_mode")))((("initializer method (AnsibleModule), parameters", "supports_check_mode")))check mode, set +supports_check_mode+
to +true+ in the AnsibleModule initializer method, as shown in
<<ENABLING_CHECK_MODE>>.

[[ENABLING_CHECK_MODE]]
.Telling Ansible the module supports check mode
====
[source,python]
----
module = AnsibleModule(
    argument_spec=dict(...),
    supports_check_mode=True)

----
====

Your module should check that check mode has been enabled by checking the value of the ++check_mode++footnote:[Phew! That was a lot of checks.] attribute of the +AnsibleModule+ object, as shown in <<CHECKING_CHECK_MODE>>. Call the +exit_json+ or +fail_json+ methods as you would normally.

[[CHECKING_CHECK_MODE]]
.Checking whether check mode is enabled
====
[source,python]
----
module = AnsibleModule(...)
...
if module.check_mode:
   # check if this module would make any changes
   would_change = would_executing_this_module_change_something()
   module.exit_json(changed=would_change)

----
====

It is up to you, the module author, to ensure that your module does not modify
the state of the host when running in check mode.((("Python", "implementing custom modules in", startref="ix_Pycusmod")))((("custom modules", "implementing in Python", startref="ix_cusmodPy")))

=== Documenting Your Module

You should document your modules according to the Ansible project standards so
that HTML documentation for your module will be correctly generated and the
_ansible-doc_ program will display documentation for your module.((("ansible-doc command-line tool"))) Ansible
uses a special YAML-based syntax for documenting modules.((("documentation", "for custom modules", id="ix_doccusmod")))((("custom modules", "documenting", id="ix_cusmoddoc")))

Near the top of your module, define a string variable called +DOCUMENTATION+ that
contains the documentation, and a string variable called +EXAMPLES+ that
contains example usage.


<<ex-10-8>> shows an example for the documentation section for our +can_reach+ module.

[[ex-10-8]]
.Example of module documentation
====
[source,python]
----
DOCUMENTATION = '''
---
module: can_reach
short_description: Checks server reachability
description:
 - Checks if a remote server can be reached
version_added: "1.8"
options:
  host:
    description:
      - A DNS hostname or IP address
    required: true
  port:
    description:
    - The TCP port number
    required: true
  timeout:
    description:
    - The amount of time trying to connect before giving up, in seconds
    required: false
    default: 3
  flavor:
    description:
    - This is a made-up option to show how to specify choices.
    required: false
    choices: ["chocolate", "vanilla", "strawberry"]
    aliases: ["flavor"]
    default: chocolate
requirements: [netcat]
author: Lorin Hochstein
notes:
  - This is just an example to demonstrate how to write a module.
  - You probably want to use the native M(wait_for) module instead.
'''

EXAMPLES = '''
# Check that ssh is running, with the default timeout
- can_reach: host=myhost.example.com port=22

# Check if postgres is running, with a timeout
- can_reach: host=db.example.com port=5432 timeout=1
'''

----
====


Ansible supports ((("ansible-doc command-line tool", "documentation markup")))limited markup in the documentation. <<DOC_MARKUP>> shows
the markup syntax supported by the Ansible documentation tool, with
recommendations about when you should use this markup.

[[DOC_MARKUP]]
.Documentation markup
[options="header"]
|======================================================================
|Type           | Syntax with example        | When to use
|URL            | U(pass:[<em>http://www.example.com</em>])  | URLs
|Module         | M(apt)                     | Module names
|Italics        | I(port)                    | Parameter names
|Constant-width | C(/bin/bash)               | File and option names
|======================================================================

The existing Ansible modules are a great source of examples for documentation.((("documentation", "for custom modules", startref="ix_doccusmod")))((("custom modules", "documenting", startref="ix_cusmoddoc")))

=== Debugging Your Module

The Ansible repository in GitHub contains a couple of scripts that allow you to
invoke your module directly on your local machine, without having to run it
by using the +ansible+ or +ansible-playbook+ commands.((("custom modules", "debugging")))((("debugging", "custom modules")))

Clone the Ansible repo:
[source,console]
----
$ git clone https://github.com/ansible/ansible.git --recursive
----

Set up your environment variables so that you can invoke the module:
[source,console]
----
$ source ansible/hacking/env-setup
----

Invoke your module:
[source,console]
----
$ ansible/hacking/test-module -m /path/to/can_reach -a "host=example.com port=81"
----

[NOTE]
====
You might get an import error, such as these:

----
ImportError: No module named yaml
ImportError: No module named jinja2.exceptions
----

If so, you'll need to install these missing dependencies:

----
pip install pyYAML jinja2
----
====

Since +example.com+ doesn't have a service that listens on port 81, our module should fail with a meaningful error message. And it does:


----
* including generated source, if any, saving to:
/Users/lorin/.ansible_module_generated
* ansiballz module detected; extracted module source to:
/Users/lorin/debug_dir
***********************************
RAW OUTPUT

{"msg": "Could not reach example.com:81", "failed": true, "invocation":
{"module_args": {"host": "example.com", "port": 81, "timeout": 3}}}


***********************************
PARSED OUTPUT
{
    "failed": true,
    "invocation": {
        "module_args": {
            "host": "example.com",
            "port": 81,
            "timeout": 3
        }
    },
    "msg": "Could not reach example.com:81"
}
----

As the output suggests, when you run this +test-module+, Ansible will generate a
Python script and copy it to _~/.ansible_module_generated_. This is a standalone
Python script that you can execute directly if you like.

Starting with Ansible 2.1.0, this Python script contains a base64-encoded
ZIP file with the actual source code from your module, as well as code to expand
the ZIP file and execute the source code within it.

This file does not take any arguments; rather, Ansible inserts the arguments directly((("ANSIBALLZ_PARAMS environment variable")))
into the file in the +ANSIBALLZ_PARAMS+ variable:

----
ANSIBALLZ_PARAMS = '{"ANSIBLE_MODULE_ARGS": {"host": "example.com", \
    "_ansible_selinux_special_fs": ["fuse", "nfs", "vboxsf", "ramfs"], \
    "port": "81"}}'
----


=== Implementing the Module in Bash

If you're going to write an Ansible module, I recommend writing it in Python because, as you saw earlier in this chapter, Ansible provides helper classes for writing your modules in Python.((("custom modules", "implementing in Bash")))((("Bash shell", "implementing custom module in"))) However, you can write modules in other languages as well. Perhaps you need to write in another language because your module depends on a third-party library that's not implemented in Python. Or maybe the module is so simple that it's easiest to write it in Bash. Or maybe you just prefer writing your scripts in Ruby.


In this section, we'll work through an example of implementing the module as a Bash script. It's going to look quite similar to the implementation in <<CAN_REACH>>. The main difference is parsing the input arguments and generating the outputs that Ansible expects.

I'm going to use the JSON format for input and use a tool called http://stedolan.github.io/jq/[jq] for parsing out JSON on the command line.((("JSON", "input format for custom module implemented in Bash")))((("jq tool"))) This means that you'll need to install jq on the host before invoking this module. <<BASH_MODULE>> shows the complete Bash implementation of our module.

[[BASH_MODULE]]
.can_reach module in Bash
====
[source,bash]
----
#!/bin/bash
# WANT_JSON

# Read the variables from the file
host=`jq -r .host < $1`
port=`jq -r .port < $1`
timeout=`jq -r .timeout < $1`

# Default timeout=3
if [[ $timeout = null ]]; then
    timeout=3
fi

# Check if we can reach the host
nc -z -w $timeout $host $port

# Output based on success or failure
if [ $? -eq 0 ]; then
    echo '{"changed": false}'
else
    echo "{\"failed\": true, \"msg\": \"could not reach $host:$port\"}"
fi
----
====

We added +WANT_JSON+ in a comment to tell Ansible that we want the input to be in JSON
syntax.

.Bash Modules with Shorthand Input
*******************************************************************************
It's possible to implement Bash modules by using the shorthand notation for input. I don't recommend doing it this way, since the simplest approach involves using the +source+ built-in, which is a potential security risk. However, if you're really determined, check out the blog post http://bit.ly/1F789tb["Shell scripts as Ansible modules"] by Jan-Piet Mens.
*******************************************************************************

=== Specifying an Alternative Location for Bash

Note that our module assumes that Bash is located at _/bin/bash_. However, not all systems will have the Bash executable in that location.((("Bash shell", "specifying alternate location for")))((("/bin/bash directory", primary-sortas="bin/bash"))) You can tell Ansible to look pass:[<span class="keep-together">elsewhere</span>] for the Bash interpreter by setting the +ansible_bash_interpreter+ variable on hosts that install it elsewhere.((("ansible_bash_interpreter variable")))


For example, let's say you have a FreeBSD host named _fileserver.example.com_ that has ((("FreeBSD platforms, Bash on")))Bash installed in _/usr/local/bin/bash_. You can create a host variable by creating the file _host_vars/fileserver.example.com_ that contains the following:

----
ansible_bash_interpreter: /usr/local/bin/bash
----

Then, when Ansible invokes this module on the FreeBSD host, it will use
_/usr/local/bin/bash_ instead of _/bin/bash_.((("#! (shebang), lines beginning with")))

Ansible determines which interpreter to use by looking for the _shebang_ (+#!+) and then looking at the base name of the first element. ((("shebang (#!)")))In our example, Ansible will see this line:

----
#!/bin/bash
----

Ansible will then look for the base name of _/bin/bash_, which is _bash_. It will then use the +ansible_bash_interpreter+ if the user specified one.

[WARNING]
====
Because of how Ansible looks for the interpreter, if your shebang calls
_/usr/bin/env_, for example:

----
#!/usr/bin/env bash
----

Ansible will mistakenly identify the interpreter as +env+ because it
will call +basename+ on _/usr/bin/env_ to identify the interpreter.

The takeaway is: don't invoke +env+ in shebang. ((("env lookup", "not invoking in shebang")))Instead, explicitly specify the location of the interpreter and override with +ansible_bash_interpreter+ (or equivalent) when needed.
====


=== Example Modules

The best way to learn how to write Ansible modules is to read the source code for the modules that ship with Ansible.((("modules", "source code for modules that ship with Ansible")))((("custom modules", "studying source code for modules shipping with Ansible"))) Check them out on https://github.com/ansible/ansible/tree/devel/lib/ansible/modules[GitHub].

In this chapter, we covered how to write modules in Python, as well as other languages, and how to avoid writing your own full-blown modules by using the +script+ module. If you do write a module, I encourage you to propose it for inclusion in the main Ansible project.((("modules", "custom", startref="ix_modcus")))((("custom modules", startref="ix_cusmod")))

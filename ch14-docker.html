<section data-type="chapter" id="ch_docker">
<h1>Docker</h1>


<p class="footnotereset1">The Docker project has taken the IT world by storm. I can&#8217;t think of another
technology that was so quickly embraced by the community.<a data-type="indexterm" id="ix_Dock" data-primary="Docker"/>  This chapter covers
how to use Ansible to create Docker images and deploy Docker
containers.</p>
<aside data-type="sidebar">
<h5>What Is a Container?</h5>
<p>A <em>container</em> is a form of virtualization.<a data-type="indexterm" data-primary="virtualization"/><a data-type="indexterm" data-primary="containers"/> When you use virtualization to run processes in a guest operating system, these guest processes have no visibility into the host operating system that runs on the physical hardware. In particular, processes running in the guest are not able to directly access physical resources, even if these guest processes are provided with the illusion that they have root access.</p>

<p>Containers are sometimes referred to as <em>operating system virtualization</em> to distinguish them from <em>hardware virtualization</em> technologies.<a data-type="indexterm" data-primary="operating system virtualization"/><a data-type="indexterm" data-primary="hardware virtualization"/> In hardware virtualization, a program called the <em>hypervisor</em> virtualizes an
entire physical machine, including a virtualized CPU, memory, and devices such
as disks and network interfaces.<a data-type="indexterm" data-primary="hypervisors"/> Because the entire machine is virtualized,
hardware virtualization is flexible. In particular, you can run an entirely
different operating system in the guest than in the host (e.g., running a
Windows Server 2012 guest inside a Red Hat Enterprise Linux host), and you can
suspend and resume a virtual machine just as you can a physical machine. This
flexibility brings with it additional overhead needed to virtualize the
hardware.</p>

<p>With operating system virtualization (containers), the guest processes
are isolated from the host by the operating system. The guest processes run on the same kernel as the host. The host operating system is responsible for ensuring that the guest processes are fully isolated from the host. When running a Linux-based container program such as Docker, the guest processes also must be Linux programs. However, the overhead is much lower than that of hardware virtualization, because you are running only a single operating system. In particular, processes start up much more quickly inside containers than inside virtual machines.</p>
</aside>

<p>Docker is more than just containers.<a data-type="indexterm" data-primary="containers" data-secondary="Docker versus"/><a data-type="indexterm" data-primary="Docker" data-secondary="containers versus"/> Think of Docker as being a platform where
containers are a building block. To use an analogy, containers are to Docker
what virtual machines are to IaaS clouds. The other two major pieces that make up Docker are
its image format and the Docker API.</p>

<p>You can think of Docker images as similar to virtual machine images.<a data-type="indexterm" data-primary="images (Docker)"/><a data-type="indexterm" data-primary="Docker" data-secondary="images"/> A Docker
image contains a filesystem with an installed operating system, along with some
metadata. One important difference is that Docker images are
layered. You create a new Docker image by taking an
existing Docker image and customizing it by adding, modifying, and
deleting files. The representation for the new Docker image contains a
reference to the original Docker image, as well as the filesystem differences
between the original Docker image and the new Docker image.<a data-type="indexterm" data-primary="Nginx" data-secondary="Docker image"/>  As an example, the
official <a href="http://bit.ly/2ktXbqS">Nginx docker image</a> is built as layers on top of
the official Debian Jessie image. The layered approach means that Docker images are smaller than traditional virtual machine images, so it&#8217;s faster to transfer Docker images over the internet than it would be to transfer a traditional virtual machine image. The Docker project maintains a registry of publicly <a href="https://registry.hub.docker.com">available images</a>.</p>

<p>Docker also supports a remote API, which enables third-party tools to interact with it.<a data-type="indexterm" data-primary="Docker" data-secondary="remote API"/> In particular, Ansible&#8217;s <code>docker</code> module uses the Docker remote API.</p>






<section data-type="sect1">
<h1>The Case for Pairing Docker with Ansible</h1>

<p>Docker containers make it easier to package your application into a single image that&#8217;s easy to deploy in different places,<a data-type="indexterm" data-primary="Docker" data-secondary="case for pairing with Ansible"/><a data-type="indexterm" data-primary="Ansible" data-secondary="pairing with Docker"/> which is why the Docker project has embraced the metaphor of the shipping container. Docker&#8217;s remote API  simplifies the automation of software systems that run on top of Docker.</p>

<p>Ansible simplifies working with Docker in two areas. One is in the
orchestration of Docker containers.<a data-type="indexterm" data-primary="containers" data-secondary="Docker, orchestration with Ansible"/> When you deploy a "Dockerized" software app,
you&#8217;re typically creating multiple Docker containers that contain different
services. These services need to communicate with each other, so you need to
connect the appropriate containers correctly and ensure they start up in the
right order. Initially, the Docker project did not provide orchestration
tools, so third-party tools emerged to fill in the gap. Ansible was built for
doing orchestration, so it&#8217;s a natural fit for deploying your Docker-based
application.</p>

<p>The other area is the creation of Docker images. The official way to create your
own Docker images is by writing special text files called <em>Dockerfiles</em>, which
resemble shell scripts.<a data-type="indexterm" data-primary="Dockerfiles"/><a data-type="indexterm" data-primary="images (Docker)" data-secondary="creating"/> For simpler images, Dockerfiles work just fine.
However, when you start to create more-complex images, you&#8217;ll quickly miss the
power that Ansible provides. Fortunately, you can use Ansible to create
playbooks.</p>
<div data-type="note">
<p>A new project called <em>Ansible Container</em> is the official approach
for using Ansible playbooks  to build Docker container images.<a data-type="indexterm" data-primary="Ansible Container"/> At the time this book was
written, the latest release of Ansible Container is 0.2. On January 29, 2017, the project maintainers
announced on the Ansible Container mailing list that the next release of
the project, dubbed <em>Ansible Container Mk. II</em>, will be substantially <span class="keep-together">different</span>.</p>

<p>Because Ansible Container is still in flux, we chose not to cover it here.
However, we do recommend that you take a look at this project once it has stabilized.</p>
</div>
</section>













<section data-type="sect1">
<h1>Docker Application Life Cycle</h1>

<p>Here&#8217;s what the typical life cycle of a Docker-based<a data-type="indexterm" data-primary="Docker" data-secondary="application life cycle"/> application looks like:</p>
<ol>
<li>
<p>Create Docker images on your local machine.</p>
</li>
<li>
<p>Push Docker images up from your local machine to the registry.</p>
</li>
<li>
<p>Pull Docker images down to your remote hosts from the registry.</p>
</li>
<li>
<p>Start up Docker containers on the remote hosts, passing in any
configuration information to the containers on startup.</p>
</li>

</ol>

<p>You typically create your Docker image on your local
machine, or on a continuous integration system that supports creating Docker
images, such as Jenkins or CircleCI. Once you&#8217;ve created your image, you need to
store it somewhere that will be convenient for downloading onto your remote
hosts.</p>

<p>Docker images typically reside in a repository called a <em>registry</em>.<a data-type="indexterm" data-primary="registry (Docker images)"/><a data-type="indexterm" data-primary="images (Docker)" data-secondary="in registry"/> The
Docker project runs a registry called <em>Docker Hub</em>, which can host both public
and private Docker images, and where the Docker command-line tools have built-in
support for pushing images up to a registry and for pulling images down from a
registry.<a data-type="indexterm" data-primary="Docker Hub"/></p>

<p>Once your Docker image is in the registry, you connect to a remote host, pull
down the container image, and then run the container. Note that if you try to
run a container whose image isn&#8217;t on the host, Docker will automatically
pull down the image from the registry,
so you do not need to explicitly issue a command to download an image from the
registry.</p>

<p>When you use Ansible to create the Docker images and start the containers
on the remote hosts, the application life cycle looks like this:</p>
<ol class="pagebreak-before">
<li>
<p>Write Ansible playbooks for creating Docker images.</p>
</li>
<li>
<p>Run the playbooks to create Docker images on your local machine.</p>
</li>
<li>
<p>Push Docker images up from your local machine to the registry.</p>
</li>
<li>
<p>Write Ansible playbooks to pull Docker images down to remote hosts and start up Docker containers on remote hosts, passing in configuration information.</p>
</li>
<li>
<p>Run Ansible playbooks to start up the containers.</p>
</li>

</ol>
</section>













<section data-type="sect1">
<h1>Example Application: Ghost</h1>

<p>In this chapter, we&#8217;re going to switch from Mezzanine to Ghost as our example
application. <a data-type="indexterm" data-primary="Docker" data-secondary="example application, Ghost"/><a data-type="indexterm" data-primary="Ghost"/>Ghost is an open source blogging platform, similar to WordPress.
The Ghost project has an official Docker container that we&#8217;ll be using.</p>

<p>What we&#8217;ll cover in this chapter:</p>

<ul>
<li>
<p>Running a Ghost container on your local machine</p>
</li>
<li>
<p>Running a Ghost container fronted by an Nginx container with SSL configured</p>
</li>
<li>
<p>Pushing a custom Nginx image to a registry</p>
</li>
<li>
<p>Deploying our Ghost and Nginx containers to a remote machine</p>
</li>
</ul>
</section>













<section data-type="sect1">
<h1>Connecting to the Docker Daemon</h1>

<p>All of the Ansible Docker modules communicate with the Docker daemon.<a data-type="indexterm" data-primary="Docker" data-secondary="connecting to Docker daemon"/> If you are
running on Linux, or if you are running on macOS using Docker for Mac, all of
the modules should just work without passing additional arguments.</p>

<p>If you are running on macOS using Boot2Docker or Docker Machine, or for
other cases where the machine that executes the module is not the same as the
machine that is running the Docker daemon, you may need to pass extra information
to the Docker modules so they can reach the Docker daemon.<a data-type="indexterm" data-primary="macOS" data-secondary="Docker connection options"/>
<a data-type="xref" href="#docker_connection_options"/> lists these options, which can be passed as either
module arguments or environment variables.<a data-type="indexterm" data-primary="docker_container module"/> See the <code>docker_container</code> module
documentation for more details about what these options do.</p>
<table id="docker_connection_options">
<caption>Docker connection options</caption>
<thead>
<tr>
<th>Module argument</th>
<th>Environment variable</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>docker_host</p></td>
<td><p>DOCKER_HOST</p></td>
<td><p><code>unix://var/run/docker.sock</code></p></td>
</tr>
<tr>
<td><p>tls_hostname</p></td>
<td><p>DOCKER_TLS_HOSTNAME</p></td>
<td><p><code>localhost</code></p></td>
</tr>
<tr>
<td><p>api_version</p></td>
<td><p>DOCKER_API_VERSION</p></td>
<td><p><code>auto</code></p></td>
</tr>
<tr>
<td><p>cert_path</p></td>
<td><p>DOCKER_CERT_PATH</p></td>
<td><p>(<em>None</em>)</p></td>
</tr>
<tr>
<td><p>ssl_version</p></td>
<td><p>DOCKER_SSL_VERSION</p></td>
<td><p>(<em>None</em>)</p></td>
</tr>
<tr>
<td><p>tls</p></td>
<td><p>DOCKER_TLS</p></td>
<td><p><code>no</code></p></td>
</tr>
<tr>
<td><p>tls_verify</p></td>
<td><p>DOCKER_TLS_VERIFY</p></td>
<td><p><code>no</code></p></td>
</tr>
<tr>
<td><p>timeout</p></td>
<td><p>DOCKER_TIMEOUT</p></td>
<td><p><code>60</code> (seconds)</p></td>
</tr>
</tbody>
</table>
</section>













<section data-type="sect1">
<h1>Running a Container on Our Local Machine</h1>

<p>The <code>docker_container</code> module starts and stops Docker containers, implementing
some of the functionality of the <code>docker</code> command-line tool such as the <code>run</code>, <code>kill</code>, and
<code>rm</code> commands.<a data-type="indexterm" data-primary="docker command-line tool"/><a data-type="indexterm" data-primary="docker_container module" data-secondary="starting and stopping containers"/><a data-type="indexterm" data-primary="containers" data-secondary="Docker, running on local machine"/></p>

<p>Assuming you have Docker installed locally, the following invocation will download the ghost
image from the Docker registry and execute it locally.<a data-type="indexterm" data-primary="Ghost" data-secondary="downloading image from Docker container and running locally"/> It will map port 2368
inside the container to 8000 on your machine, so you can access Ghost at
<em>http://localhost:8000</em>.</p>

<pre data-type="programlisting">$ ansible localhost -m docker_container -a "name=test-ghost image=ghost \
  ports=8000:2368"</pre>

<p>The first time you run this, it may take some time for Docker to download the
image.<a data-type="indexterm" data-primary="docker ps command"/> If it succeeds, the <code>docker ps</code> command will show the running container:</p>

<pre data-type="programlisting">$ docker ps
CONTAINER ID   IMAGE           COMMAND                  CREATED
48e69da90023   ghost           "/entrypoint.sh np..."   37 seconds ago
               STATUS          PORTS                    NAMES
               Up 36 seconds   0.0.0.0:8000-&gt;2368/tcp   test-ghost</pre>

<p>To stop and remove the container:</p>

<pre data-type="programlisting">$ ansible localhost -m docker_container -a "name=test-ghost state=absent"</pre>

<p>The <code>docker_container</code> module supports many options: if you can
pass an argument by using the <code>docker</code> command-line tool, you&#8217;re likely to find an
equivalent option on the module.<a data-type="indexterm" data-primary="docker_container module" data-secondary="support for many options"/></p>
</section>













<section data-type="sect1">
<h1>Building an Image from a Dockerfile</h1>

<p>The stock Ghost image works great on its own, but if we want to ensure that access is
secure, we&#8217;ll need to front it with a web server configured for TLS.<a data-type="indexterm" id="ix_Dockimg" data-primary="Docker" data-secondary="building an image from a Dockerfile"/><a data-type="indexterm" id="ix_imgDock" data-primary="images (Docker)" data-secondary="building from a Dockerfile"/></p>

<p>The Nginx project puts out a stock Nginx image,<a data-type="indexterm" data-primary="Nginx" data-secondary="configuration to be frontend for Ghost"/><a data-type="indexterm" data-primary="Ghost" data-secondary="Nginx configuration as frontend for"/> but we&#8217;ll need to configure it
to act as a frontend for Ghost and to enable TLS, similar to the way we did it in
<a data-type="xref" href="#deploying_mezzanine"/> for Mezzanine. <a data-type="xref" href="#Dockerfile"/> shows the Dockerfile for
this.</p>
<div id="Dockerfile" data-type="example">
<h5>Dockerfile</h5>

<pre data-type="programlisting">FROM nginx
RUN rm /etc/nginx/conf.d/default.conf
COPY ghost.conf /etc/nginx/conf.d/ghost.conf</pre></div>

<p><a data-type="xref" href="#ghost.conf"/> shows the Nginx configuration for being a frontend for Ghost.
The main difference between this one and the one for Mezzanine is that in this
case Nginx is communicating with Ghost by using a TCP socket (port 2368), whereas
in the Mezzanine case the communication was over a Unix domain socket.</p>

<p>The other difference is<a data-type="indexterm" data-primary="TLS (Transport Layer Security)" data-secondary="Nginx configuration for"/> that the path containing the TLS files is <em>/certs</em>.</p>
<div id="ghost.conf" data-type="example">
<h5>ghost.conf</h5>

<pre data-type="programlisting">upstream ghost {
    server ghost:2368;
}

server {

    listen 80;

    listen 443 ssl;

    client_max_body_size 10M;
    keepalive_timeout    15;

    ssl_certificate      /certs/nginx.crt;
    ssl_certificate_key  /certs/nginx.key;
    ssl_session_cache    shared:SSL:10m;
    ssl_session_timeout  10m;
    # # ssl_ciphers entry is too long to show in this book
    ssl_prefer_server_ciphers on;

    location / {
        proxy_redirect      off;
        proxy_set_header    Host                    $host;
        proxy_set_header    X-Real-IP               $remote_addr;
        proxy_set_header    X-Forwarded-For         $proxy_add_x_forwarded_for;
        proxy_set_header    X-Forwarded-Protocol    $scheme;
        proxy_pass          http://ghost;
    }
}</pre></div>

<p>This configuration assumes that Nginx can reach the Ghost server via the
hostname <code>ghost</code>. When we deploy these containers, we must ensure that this is
the case; otherwise, the Nginx container will not be able to reach the Ghost
container.</p>

<p>Assuming we put the Dockerfile and <em>nginx.conf</em> file in a directory named <em>nginx</em>,
this task will create an image named <em>lorin/nginx-ghost</em>. We use the prefix
<em>ansiblebook/</em> since this will eventually be pushed to the
<em>ansiblebook/nginx-ghost</em> Docker Hub <span class="keep-together">repository</span>:</p>

<pre data-type="programlisting">- name: create Nginx image
  docker_image:
    name: ansiblebook/nginx-ghost
    path: nginx</pre>

<p>We can confirm <a data-type="indexterm" data-primary="docker images command"/>this with the <code>docker images</code> command:</p>

<pre data-type="programlisting">$ docker images
REPOSITORY                TAG                 IMAGE ID            CREATED
ansiblebook/nginx-ghost   latest              23fd848947a7        37 seconds ago
ghost                     latest              066a22d980f4        3 days ago
nginx                     latest              cc1b61406712        11 days ago
                          SIZE
                          182 MB
                          326 MB
                          182 MB</pre>

<p>Note that invoking the <code>docker_image</code> module to build an image will have no
effect if an image with that name already exists, even if you&#8217;ve made changes to
the Dockerfile.<a data-type="indexterm" data-primary="docker_images module"/> If you&#8217;ve made changes to the Dockerfile and want to rebuild, you need to add the
<code>force: yes</code> option.</p>

<p>In general, though, it&#8217;s a good idea to add a <code>tag</code> option with a version
number, and increment this each time you do a new build. The <code>docker_image</code>
module would then build the new image without needing to be forced.<a data-type="indexterm" data-primary="Docker" data-secondary="building an image from a Dockerfile" data-startref="ix_Dockimg"/><a data-type="indexterm" data-primary="images (Docker)" data-secondary="building from a Dockerfile" data-startref="ix_imgDock"/></p>
</section>













<section data-type="sect1">
<h1>Orchestrating Multiple Containers on Our Local Machine</h1>

<p>It&#8217;s common to run multiple Docker containers and wire them up together.<a data-type="indexterm" data-primary="Docker" data-secondary="orchestrating multiple containers on local machine"/><a data-type="indexterm" data-primary="containers" data-secondary="orchestrating multiple Docker containers on local machine"/> During
development, you typically run all of these containers together on your local
machine. In production, these containers are commonly hosted on
different machines.</p>

<p>For local development where all of the containers are running on the same
machine, the Docker project has a tool called <em>Docker Compose</em> that makes it
simpler to bring the containers up and wire them together.<a data-type="indexterm" data-primary="Docker Compose tool"/><a data-type="indexterm" data-primary="docker_service module"/> The <code>docker_service</code>
module can be used to control Docker Compose to bring the services up or down.</p>

<p><a data-type="xref" href="#docker-compose.yml"/> shows a <em>docker-compose.yml</em> file that will start up Nginx
and Ghost. <a data-type="indexterm" data-primary="Nginx" data-secondary="docker-compose file starting up"/><a data-type="indexterm" data-primary="Ghost" data-secondary="docker-compose file starting up"/>The file assumes there&#8217;s a <em>./certs</em> directory that contains the TLS
certificate files.<a data-type="indexterm" data-primary="TLS (Transport Layer Security)" data-secondary="certificates"/><a data-type="indexterm" data-primary="certificates" data-secondary="directory containing TLS certificates"/></p>
<div id="docker-compose.yml" data-type="example">
<h5>docker-compose.yml</h5>

<pre data-type="programlisting">version: '2'
services:
  nginx:
    image: ansiblebook/nginx-ghost
    ports:
      - "8000:80"
      - "8443:443"
    volumes:
      - ${PWD}/certs:/certs
    links:
      - ghost
  ghost:
    image: ghost</pre></div>

<p><a data-type="xref" href="#local.yml"/> shows a playback that creates the custom Nginx image file, creates
self-signed certificates, and then starts up the services specified by
<a data-type="xref" href="#docker-compose.yml"/>.</p>
<div id="local.yml" data-type="example">
<h5>ghost.yml</h5>

<pre data-type="programlisting">---
- name: Run Ghost locally
  hosts: localhost
  gather_facts: False
  tasks:
    - name: create Nginx image
      docker_image:
        name: ansiblebook/nginx-ghost
        path: nginx
    - name: create certs
      command: &gt;
        openssl req -new -x509 -nodes
        -out certs/nginx.crt -keyout certs/nginx.key
        -subj '/CN=localhost' -days 3650
        creates=certs/nginx.crt
    - name: bring up services
      docker_service:
        project_src: .
        state: present</pre></div>
</section>













<section data-type="sect1">
<h1>Pushing Our Image to the Docker Registry</h1>

<p>We&#8217;ll use a separate playbook to publish our image to Docker Hub; it&#8217;s shown as
<a data-type="xref" href="#publish.yml"/>.<a data-type="indexterm" id="ix_imgDockpush" data-primary="images (Docker)" data-secondary="pushing our image to Docker registry"/><a data-type="indexterm" id="ix_Dockimgreg" data-primary="Docker" data-secondary="pushing our image to Docker registry"/><a data-type="indexterm" id="ix_registry" data-primary="registry (Docker images)" data-secondary="pushing our image to"/> Note that the <code>docker_login</code> module must be invoked first to
log in to the registry before the image is to be pushed.<a data-type="indexterm" data-primary="docker_login module"/> The <code>docker_login</code> and
<code>docker_image</code> modules both default to Docker Hub<a data-type="indexterm" data-primary="Docker Hub"/> as the registry.</p>
<div id="publish.yml" data-type="example">
<h5>publish.yml</h5>

<pre data-type="programlisting">- name: publish images to docker hub
  hosts: localhost
  gather_facts: False
  vars_prompt:
    - name: username
      prompt: Enter Docker Registry username
    - name: email
      prompt: Enter Docker Registry email
    - name: password
      prompt: Enter Docker Registry password
      private: yes
  tasks:
    - name: authenticate with repository
      docker_login:
        username: "{{ username }}"
        email: "{{ email }}"
        password: "{{ password }}"
    - name: push image up
      docker_image:
        name: ansiblebook/nginx-ghost
        push: yes</pre></div>

<p>If you wish to use a different registry, specify a <code>registry_url</code> option to <code>docker_login</code>
and prefix the image name with the hostname and port (if not using the standard
HTTP/HTTPS port) of the registry.  <a data-type="xref" href="#publish-yml-alternate-registry"/> shows how the tasks would change when using a
registry at <em>http://reg.example.com</em>. The playbook for creating the image would
also need to change to reflect the new name of the image:
<em>reg.example.com/ansiblebook/nginx-ghost</em>.</p>
<div id="publish-yml-alternate-registry" data-type="example">
<h5>publish.yml with custom registry</h5>

<pre data-type="programlisting">  tasks:
    - name: authenticate with repository
      docker_login:
        username: "{{ username }}"
        email: "{{ email }}"
        password: "{{ password }}"
        registry_url: http://reg.example.com
    - name: push image up
      docker_image:
        name: reg.example.com/ansiblebook/nginx-ghost
        push: yes</pre></div>

<p>We can test pushing to Docker registries by using a local registry.
<a data-type="xref" href="#publish-local.yml"/> starts a registry inside a Docker container, tags
the <em>ansiblebook/nginx-ghost</em> image as <em>localhost:5000/ansiblebook/nginx-ghost</em>,
and pushes it to the registry. Note that the local registry doesn&#8217;t require
authentication by default, so there&#8217;s no task that involves <code>docker_login</code> in
this playbook.</p>
<div id="publish-local.yml" data-type="example">
<h5>publish.yml with a local registry</h5>

<pre data-type="programlisting">- name: publish images to local docker registry
  hosts: localhost
  gather_facts: False
  vars:
    repo_port: 5000
    repo: "localhost:{{repo_port}}"
    image: ansiblebook/nginx-ghost
  tasks:
    - name: start a registry locally
      docker_container:
        name: registry
        image: registry:2
        ports: "{{ repo_port }}:5000"
    - debug:
        msg: name={{ image }} repo={{ repo }}/{{ image }}
    - name: tag the nginx-ghost image to the repository
      docker_image:
        name: "{{ image }}"
        repository: "{{ repo }}/{{ image }}"
        push: yes</pre></div>

<p>We can verify the upload worked by downloading the manifest:</p>

<pre data-type="programlisting">$ curl http://localhost:5000/v2/ansiblebook/nginx-ghost/manifests/latest
{
   "schemaVersion": 1,
   "name": "ansiblebook/nginx-ghost",
   "tag": "latest",
   ...
}</pre>
</section>













<section data-type="sect1">
<h1>Querying Local Images</h1>

<p>The <code>docker_image_facts</code> module allows you to query the metadata on a locally
stored image.<a data-type="indexterm" data-primary="images (Docker)" data-secondary="pushing our image to Docker registry" data-startref="ix_imgDockpush"/><a data-type="indexterm" data-primary="Docker" data-secondary="pushing our image to Docker registry" data-startref="ix_Dockimgreg"/><a data-type="indexterm" data-primary="registry (Docker images)" data-secondary="pushing our image to"/> <a data-type="xref" href="#image-facts.yml"/> shows an example of a playbook that uses this
module to query the ghost image for the exposed port and volumes.<a data-type="indexterm" id="ix_Dockquery" data-primary="Docker" data-secondary="querying local images"/><a data-type="indexterm" id="ix_imgDockquery" data-primary="images (Docker)" data-secondary="querying local images"/></p>
<div id="image-facts.yml" data-type="example">
<h5>image-facts.yml</h5>

<pre data-type="programlisting">---
- name: get exposed ports and volumes
  hosts: localhost
  gather_facts: False
  vars:
    image: ghost
  tasks:
    - name: get image info
      docker_image_facts: name=ghost
      register: ghost
    - name: extract ports
      set_fact:
        ports: "{{ ghost.images[0].Config.ExposedPorts.keys() }}"
    - name: we expect only one port to be exposed
      assert:
        that: "ports|length == 1"
    - name: output exposed port
      debug:
        msg: "Exposed port: {{ ports[0] }}"
    - name: extract volumes
      set_fact:
        volumes: "{{ ghost.images[0].Config.Volumes.keys() }}"
    - name: output volumes
      debug:
        msg: "Volume: {{ item }}"
      with_items: "{{ volumes }}"</pre></div>

<p>The output looks like this:</p>

<pre data-type="programlisting">$ ansible-playbook image-facts.yml

PLAY [get exposed ports and volumes] *******************************************

TASK [get image info] **********************************************************
ok: [localhost]

TASK [extract ports] ***********************************************************
ok: [localhost]

TASK [we expect only one port to be exposed] ***********************************
ok: [localhost] =&gt; {
    "changed": false,
    "msg": "All assertions passed"
}

TASK [output exposed port] *****************************************************
ok: [localhost] =&gt; {
    "msg": "Exposed port: 2368/tcp"
}

TASK [extract volumes] *********************************************************
ok: [localhost]

TASK [output volumes] **********************************************************
ok: [localhost] =&gt; (item=/var/lib/ghost) =&gt; {
    "item": "/var/lib/ghost",
    "msg": "Volume: /var/lib/ghost"
}

PLAY RECAP *********************************************************************
localhost                  : ok=6    changed=0    unreachable=0    failed=0</pre>
</section>













<section data-type="sect1">
<h1>Deploying the Dockerized Application</h1>

<p>By default, Ghost uses SQLite as its database backend.<a data-type="indexterm" data-primary="Docker" data-secondary="querying local images" data-startref="x_Dockquery"/><a data-type="indexterm" data-primary="images (Docker)" data-secondary="querying local images" data-startref="ix_imgDockquery"/> For deployment, we&#8217;re
going to use Postgres as the database backend, for the reasons we
discussed in <a data-type="xref" href="#introducing_mezzanine"/>.<a data-type="indexterm" id="ix_Ghostdep" data-primary="Ghost" data-secondary="deploying Dockerized application"/><a data-type="indexterm" id="ix_Dockdep" data-primary="Docker" data-secondary="deploying Dockerized application"/></p>

<p>We&#8217;re going to deploy onto two separate machines. One machine (<code>ghost</code>)
will run the Ghost container and the Nginx container. The other machine
(<code>postgres</code>) will run a Postgres container that will serve as a persistent store
for the Ghost data.</p>

<p>This example assumes the following variables are defined somewhere such as
<em>group_vars/all</em>, where they are in scope for the frontend and backend
machines:</p>

<ul>
<li>
<p><code>database_name</code></p>
</li>
<li>
<p><code>database_user</code></p>
</li>
<li>
<p><code>database_password</code></p>
</li>
</ul>








<section data-type="sect2">
<h2>Backend: Postgres</h2>

<p>To configure the Postgres container, we need to pass the database user, database
password, and database name as environment variables that the container expects.
We also want to mount a directory from a host machine as a volume for storing
the persistent data, because we don&#8217;t want our persistent data to disappear if
the container stops and gets removed.</p>

<p><a data-type="xref" href="#deploy_postgres"/> shows the playbook for deploying the Postgres container. It
has only two tasks: one to create the directory that will hold the data, and the
other to start the Postgres container. Note that this playbook assumes that
Docker Engine is already installed on the <code>postgres</code> host.</p>
<div id="deploy_postgres" data-type="example">
<h5>postgres.yml</h5>

<pre data-type="programlisting">- name: deploy postgres
  hosts: postgres
  become: True
  gather_facts: False
  vars:
    data_dir: /data/pgdata
  tasks:
    - name: create data dir with correct ownership
      file:
        path: "{{ data_dir }}"
        state: directory
    - name: start postgres container
      docker_container:
        name: postgres_ghost
        image: postgres:9.6
        ports:
          - "0.0.0.0:5432:5432"
        volumes:
          - "{{ data_dir }}:/var/lib/postgresql/data"
        env:
          POSTGRES_USER: "{{ database_user }}"
          POSTGRES_PASSWORD: "{{ database_password }}"
          POSTGRES_DB: "{{ database_name }}"</pre></div>
</section>













<section data-type="sect2">
<h2>Frontend</h2>

<p>The frontend deployment is more complex, since we have two containers to
deploy: Ghost and Nginx.<a data-type="indexterm" data-primary="Docker" data-secondary="deploying Dockerized application" data-tertiary="frontend"/> We also need to wire them up, and we need to pass
configuration information to the Ghost container so it can access the Postgres
database.</p>

<p>We&#8217;re going to use Docker networks to enable the Nginx container to connect to
the Ghost container.<a data-type="indexterm" data-primary="containers" data-secondary="enabling Nginx container to connect to Ghost container"/><a data-type="indexterm" data-primary="Nginx" data-secondary="enabling Nginx container to connect to Ghost container"/><a data-type="indexterm" data-primary="networks (Docker), creating"/> Networks replace the legacy <code>links</code> functionality that was
previously used for connecting containers. Using Docker networks, you
create a custom Docker network, attach containers to that network, and the
containers can access each other by using the container names as hostnames.</p>

<p>Creating a Docker network is simple:</p>

<pre data-type="programlisting">- name: create network
  docker_network: name=ghostnet</pre>

<p>It makes more sense to use a variable for the network name, since we&#8217;ll need to
reference it for each container we bring up. This is how our playbook will
start:</p>

<pre data-type="programlisting">- name: deploy ghost
  hosts: ghost
  become: True
  gather_facts: False
  vars:
    url: "https://{{ ansible_host }}"
    database_host: "{{ groups['postgres'][0] }}"
    data_dir: /data/ghostdata
    certs_dir: /data/certs
    net_name: ghostnet
  tasks:
    - name: create network
      docker_network: "name={{ net_name }}"</pre>

<p>Note that this playbook assumes there&#8217;s a group named <code>postgres</code> that contains a
single host; it uses this information to populate the <code>database_host</code> variable.</p>
</section>













<section data-type="sect2">
<h2>Frontend: Ghost</h2>

<p>We need to configure Ghost to connect to the Postgres database, as well as to
run in production mode by passing the <code>--production</code> flag to the <code>npm start</code>
command.<a data-type="indexterm" data-primary="Ghost" data-secondary="deploying Dockerized application" data-tertiary="frontend, Ghost"/><a data-type="indexterm" data-primary="Docker" data-secondary="deploying Dockerized application" data-tertiary="frontend, Ghost"/></p>

<p>We also want to ensure that the persistent files that it generates are written to a
volume mount.</p>

<p>Here&#8217;s the part of the playbook that creates the directory that will hold the
persistent data, generates a Ghost config file from a template, and starts up
the container, connected to the <code>ghostnet</code> network:</p>

<pre data-type="programlisting">    - name: create ghostdata directory
      file:
        path: "{{ data_dir }}"
        state: directory
    - name: generate the config file
      template: src=templates/config.js.j2 dest={{ data_dir }}/config.js
    - name: start ghost container
      docker_container:
        name: ghost
        image: ghost
        command: npm start --production
        volumes:
          - "{{ data_dir }}:/var/lib/ghost"
        networks:
          - name: "{{ net_name }}"</pre>

<p>Note that we don&#8217;t need to publish any ports here, since only the Nginx
container will communicate with the Ghost container.</p>
</section>













<section data-type="sect2">
<h2>Frontend: Nginx</h2>

<p>The Nginx container had its configuration hardwired into it when we created the
<em>ansiblebook/nginx-ghost</em> image: it is configured to connect to <code>ghost:2368</code>.<a data-type="indexterm" data-primary="Ghost" data-secondary="deploying Dockerized application" data-tertiary="frontend, Nginx"/><a data-type="indexterm" data-primary="Docker" data-secondary="deploying Dockerized application" data-tertiary="frontend, Nginx"/><a data-type="indexterm" data-primary="Nginx" data-secondary="frontend for Dockerized Ghost application"/></p>

<p>However, we do need to copy the TLS certificates. <a data-type="indexterm" data-primary="certificates" data-secondary="generating self-signed TLS certificates"/><a data-type="indexterm" data-primary="TLS (Transport Layer Security)" data-secondary="certificates" data-tertiary="generating self-signed certificates"/>As in previous examples, we&#8217;ll
just generate self-signed certificates:</p>

<pre data-type="programlisting">    - name: create certs directory
      file:
        path: "{{ certs_dir }}"
        state: directory
    - name: generate tls certs
      command: &gt;
        openssl req -new -x509 -nodes
        -out "{{ certs_dir }}/nginx.crt" -keyout "{{ certs_dir }}/nginx.key"
        -subj "/CN={{ ansible_host}}" -days 3650
        creates=certs/nginx.crt
    - name: start nginx container
      docker_container:
        name: nginx_ghost
        image: ansiblebook/nginx-ghost
        pull: yes
        networks:
          - name: "{{ net_name }}"
        ports:
          - "0.0.0.0:80:80"
          - "0.0.0.0:443:443"
        volumes:
          - "{{ certs_dir }}:/certs"</pre>
</section>













<section data-type="sect2">
<h2>Cleaning Out Containers</h2>

<p>Ansible makes it easy to stop and remove containers, which is useful
when you&#8217;re developing and testing deployment scripts.<a data-type="indexterm" data-primary="containers" data-secondary="cleaning out Ghost containers"/><a data-type="indexterm" data-primary="Docker" data-secondary="deploying Dockerized application" data-tertiary="cleaning out containers"/><a data-type="indexterm" data-primary="Ghost" data-secondary="deploying Dockerized application" data-tertiary="cleaning out containers"/> Here is a playbook
that cleans up the <code>ghost</code> host.</p>

<pre data-type="programlisting">- name: remove all ghost containers and networks
  hosts: ghost
  become: True
  gather_facts: False
  tasks:
    - name: remove containers
      docker_container:
        name: "{{ item }}"
        state: absent
      with_items:
        - nginx_ghost
        - ghost
    - name: remove network
      docker_network:
        name: ghostnet
        state: absent</pre>
</section>













<section data-type="sect2">
<h2>Connecting Directly to Containers</h2>

<p>Ansible has support for interacting directly with running containers.<a data-type="indexterm" data-primary="Ghost" data-secondary="deploying Dockerized application" data-tertiary="connecting directly to containers"/><a data-type="indexterm" data-primary="Docker" data-secondary="deploying Dockerized application" data-tertiary="connecting directly to containers"/><a data-type="indexterm" data-primary="containers" data-secondary="connecting directly to, using Docker inventory plugin"/> Ansible&#8217;s
Docker inventory plugin will automatically generate an inventory of accessible
running hosts, and its Docker connection plugin does the equivalent of <code>docker
exec</code> to execute processes in the context of a running container.<a data-type="indexterm" data-primary="inventory" data-secondary="Docker inventory plugin"/></p>

<p>The Docker inventory plugin is available in the GitHub <em>ansible/ansible</em> repo at
<em>contrib/inventory/docker.py</em>.<a data-type="indexterm" data-primary="GitHub repositories" data-secondary="Docker inventory plugin"/> By default, this plugin accesses the Docker daemon
running on your local machine. It can be configured to connect to Docker daemons
on remote machines using Docker&#8217;s REST API, or to connect to running Docker
containers that have an SSH server running inside them. Both of these require additional setup work. To access the Docker API remotely, the host running
Docker must be configured to bind to a TCP port. To connect to a container via
SSH, the container must be configured to start up an SSH server. We don&#8217;t cover
those scenarios here, but you can check out the example configuration file in
the repo at <em>contrib/inventory/docker.yml</em>.</p>

<p>Assuming we have the following containers running locally:</p>

<pre data-type="programlisting">CONTAINER ID        IMAGE                    NAMES
63b6767de77f        ansiblebook/nginx-ghost  ch14_nginx_1
057d72a95016        ghost                    ch14_ghost_1</pre>

<p>the <em>docker.py</em> inventory script creates a host per name. In this case:</p>

<ul>
<li>
<p><code>ch14_nginx_1</code></p>
</li>
<li>
<p><code>ch14_ghost_1</code></p>
</li>
</ul>

<p>It also creates groups for short ID, long ID, Docker image, and a group for all
running containers. Continuing on with our example, the created groups are as follows:</p>

<ul>
<li>
<p><code>63b6767de77fe</code> (<code>ch14_nginx_1</code>)</p>
</li>
<li>
<p><code>63b6767de77fe01aa6d840dd897329766bbd3dc60409001cc36e900f8d501d6d</code> (<code>ch14_nginx_1</code>)</p>
</li>
<li>
<p><code>057d72a950163</code> (<code>ch14_ghost_1</code>)</p>
</li>
<li>
<p><code>057d72a950163769c2bcc1ecc81ba377d03c39b1d19f8f4a9f0c748230b42c5c</code> (<code>ch14_ghost_1</code>)</p>
</li>
<li>
<p><code>image_ansiblebook/nginx-ghost</code> (<code>ch14_nginx_1</code>)</p>
</li>
<li>
<p><code>image_ghost</code> (<code>ch14_ghost_1</code>)</p>
</li>
<li>
<p><code>running</code> (<code>ch14_nginx_1</code>, <code>ch14_ghost_1</code>)</p>
</li>
</ul>

<p>Here&#8217;s how we combine the Docker dynamic inventory script with the Docker
connection plugin (enabled by passing <code>-c docker</code> as an argument) to list all of
the processes running inside each container:</p>

<pre data-type="programlisting">$ ansible -c docker running -m raw -a 'ps aux'

ch14_ghost_1 | SUCCESS | rc=0 &gt;&gt;
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
user         1  0.0  2.2 1077892 45040 ?       Ssl  05:19   0:00 npm
user        34  0.0  0.0   4340   804 ?        S    05:19   0:00 sh -c node ind
user        35  0.0  5.9 1255292 121728 ?      Sl   05:19   0:02 node index
root       108  0.0  0.0   4336   724 ?        Ss   06:20   0:00 /bin/sh -c ps
root       114  0.0  0.1  17500  2076 ?        R    06:20   0:00 ps aux


ch14_nginx_1 | SUCCESS | rc=0 &gt;&gt;
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.2  46320  5668 ?        Ss   05:19   0:00 nginx: master
nginx        6  0.0  0.1  46736  3020 ?        S    05:19   0:00 nginx: worker
root        71  0.0  0.0   4336   752 ?        Ss   06:20   0:00 /bin/sh -c ps
root        77  0.0  0.0  17500  2028 ?        R    06:20   0:00 ps aux</pre>
</section>





</section>













<section data-type="sect1">
<h1>Ansible Container</h1>

<p>Coinciding with the release of Ansible 2.1, the Ansible project released
a new tool called <em>Ansible Container</em> to simplify working with Docker images
and containers.<a data-type="indexterm" id="ix_DockAC" data-primary="Docker" data-secondary="Ansible Container"/> We cover Ansible Container 0.9, which coincided with the release
of Ansible 2.3.<a data-type="indexterm" id="ix_AnsCont" data-primary="Ansible Container"/></p>

<p>Ansible Container does quite a few things. In particular, you
can use it to do the <span class="keep-together">following</span>:</p>

<ul>
<li>
<p>Create new images (replaces Dockerfiles)</p>
</li>
<li>
<p>Publish Docker images to registries (replaces <code>docker push</code>)</p>
</li>
<li>
<p>Run Docker containers in development mode (replaces Docker Compose)</p>
</li>
<li>
<p>Deploy to a production cloud (alternative to Docker Swarm)</p>
</li>
</ul>

<p>As of this writing, Ansible Container supports deploying to Kubernetes and
OpenShift, although this list is likely to grow.<a data-type="indexterm" data-primary="Kubernetes"/><a data-type="indexterm" data-primary="OpenShift"/> If you don&#8217;t run on one of
these environments, don&#8217;t worry: you can write a playbook by using the <code>docker_container</code> module
(described later in this chapter) to pull down and start your containers on
whatever production environment you like.</p>








<section data-type="sect2">
<h2>The Conductor</h2>

<p>Ansible Container enables you to configure Docker images by using Ansible roles
instead of Dockerfiles.<a data-type="indexterm" data-primary="Ansible Container" data-secondary="Conductor"/> When using Ansible to configure hosts, Python must be
installed on the host. However, this requirement is generally considered
undesirable for Docker containers because users typically want minimal
containers; users don&#8217;t want to have Python installed in a container if
that container won&#8217;t actually need Python.</p>

<p>Ansible Container eliminates the need to have Python installed inside the
container<a data-type="indexterm" data-primary="Conductor"/> by using a special container called the <em>Conductor</em>, and taking
advantage of Docker&#8217;s ability to mount volumes from one container to another.</p>

<p>When you run Ansible Container, it creates a local directory named
<em>ansible-deployment</em>, copies all the files that the Conductor
needs,  and mounts the directory from your local machine into the Conductor.</p>

<p>Ansible Container mounts directories containing the Python runtime and any
needed library dependencies <a data-type="indexterm" data-primary="Python" data-secondary="Ansible Container mounting runtime to containers being configured"/>from the Conductor container into the containers
that are being configured. It does this by mounting <em>/usr</em> from the Conductor container
instance to <span class="keep-together"><em>/_usr</em></span> inside the container being configured, and configures Ansible to use the Python interpreter under <span class="keep-together"><em>/_usr</em></span>.
For this to work properly, the Linux distribution of the Docker container you
use for the Conductor should match the Linux distribution of the base image of
the Docker containers that you are configuring.</p>

<p>If your Conductor base image is an official image from one of the supported Linux
distributions, Ansible Container will automatically add some required
packages to the container.  As of 0.9.0, the supported distributions are
Fedora, CentOS, Debian, Ubuntu, and Alpine. You can use an unsupported base image,
but you must ensure that it has the required packages installed.</p>

<p>See the <em>container/docker/templates/conductor-dockerfile.j2</em> file in the <a href="https://github.com/ansible/ansible-container">Ansible
Container GitHub repository</a> for
information on which packages are installed into the Conductor image.</p>

<p>If you don&#8217;t want Ansible Container to mount the runtime from the Conductor into the container
being configured, you can disable this behavior by passing the
<code>--use-local-python</code> flag to the <code>ansible-container</code> command. Ansible Container will then use the native Python interpreter of the container image
being configured.<a data-type="indexterm" data-primary="ansible-container --use-local-python command"/></p>
</section>













<section data-type="sect2">
<h2>Creating Docker Images</h2>

<p>Let&#8217;s use Ansible Container to build that simple Nginx image from <a data-type="xref" href="#Dockerfile"/>.<a data-type="indexterm" id="ix_DockACimg" data-primary="Docker" data-secondary="Ansible Container" data-tertiary="creating Docker images"/><a data-type="indexterm" id="ix_AnsContimg" data-primary="Ansible Container" data-secondary="creating Docker images"/></p>










<section data-type="sect3">
<h3>Creating the initial files</h3>

<p>The first thing we must do is run <a data-type="indexterm" data-primary="ansible-container init command"/>the initialize command:</p>

<pre data-type="programlisting">$ ansible-container init</pre>

<p>This command creates a set of files in the current directory:</p>

<pre data-type="programlisting">.
├── ansible-requirements.txt
├── ansible.cfg
├── container.yml
├── meta.yml
└── requirements.yml</pre>
</section>













<section data-type="sect3">
<h3>Creating the roles</h3>

<p>Next, we need a role that will configure our container.<a data-type="indexterm" data-primary="Ansible Container" data-secondary="creating Docker images" data-tertiary="creating roles"/><a data-type="indexterm" data-primary="roles" data-secondary="ghost-nginx, creating for Dockerized application"/> We&#8217;ll call our role
<code>ghost-nginx</code>, since it configures an Nginx image for fronting Ghost.</p>

<p>This role will be very simple; it just needs the <em>ghost.conf</em> configuration file
from <a data-type="xref" href="#ghost.conf"/> and a task file that implements the functionality of
<a data-type="xref" href="#Dockerfile"/>. Here&#8217;s the directory structure for the role:</p>

<pre data-type="programlisting" class="pagebreak-before">.
└── roles
    └── ghost-nginx
        ├── files
        │   └── ghost.conf
        └── tasks
            └── main.yml</pre>

<p>Here&#8217;s the <em>tasks/main.yml</em> file:</p>

<pre data-type="programlisting">---
- name: remove default config
  file:
    path: /etc/nginx/conf.d/default.conf
    state: absent
- name: add ghost config
  copy:
    src: ghost.conf
    dest: /etc/nginx/conf.d/ghost.conf</pre>
</section>













<section data-type="sect3">
<h3>Configuring container.yml</h3>

<p>Next, we&#8217;ll configure <em>container.yml</em> to use our role to build the container, as shown in <a data-type="xref" href="#container.yml"/>. This
file is similar to a Docker Compose file, with additional fields that are
Ansible-specific, and support for Jinja2-style variable substitution and filters.<a data-type="indexterm" data-primary="containers" data-secondary="configuring container.yml for Ansible Container"/></p>
<div id="container.yml" data-type="example">
<h5>container.yml</h5>

<pre data-type="programlisting">version: "2" <a class="co" id="co_docker_CO1-1" href="#callout_docker_CO1-1"><img src="callouts/1.png" alt="1"/></a>
settings:
  conductor_base: debian:jessie <a class="co" id="co_docker_CO1-2" href="#callout_docker_CO1-2"><img src="callouts/2.png" alt="2"/></a>
services: <a class="co" id="co_docker_CO1-3" href="#callout_docker_CO1-3"><img src="callouts/3.png" alt="3"/></a>
  ac-nginx: <a class="co" id="co_docker_CO1-4" href="#callout_docker_CO1-4"><img src="callouts/4.png" alt="4"/></a>
    from: nginx <a class="co" id="co_docker_CO1-5" href="#callout_docker_CO1-5"><img src="callouts/5.png" alt="5"/></a>
    command: [nginx, -g, daemon off;] <a class="co" id="co_docker_CO1-6" href="#callout_docker_CO1-6"><img src="callouts/6.png" alt="6"/></a>
    roles:
      - ghost-nginx <a class="co" id="co_docker_CO1-7" href="#callout_docker_CO1-7"><img src="callouts/7.png" alt="7"/></a>
registries: {} <a class="co" id="co_docker_CO1-8" href="#callout_docker_CO1-8"><img src="callouts/8.png" alt="8"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" id="callout_docker_CO1-1" href="#co_docker_CO1-1"><img src="callouts/1.png" alt="1"/></a></dt>
<dd><p>This tells Ansible Container to support Docker Compose version 2 schemas.
The default is version 1, but you probably always want version 2.</p></dd>
<dt><a class="co" id="callout_docker_CO1-2" href="#co_docker_CO1-2"><img src="callouts/2.png" alt="2"/></a></dt>
<dd><p>We are using <code>debian:jessie</code> as the base image for our Conductor container,
because we will be customizing the official Nginx image, which uses
<code>debian:jessie</code> as its base image.</p></dd>
<dt><a class="co" id="callout_docker_CO1-3" href="#co_docker_CO1-3"><img src="callouts/3.png" alt="3"/></a></dt>
<dd><p>The <code>services</code> field is a map whose keys are the names of the containers we
are going to create. In this example, there is only a single container.</p></dd>
<dt><a class="co" id="callout_docker_CO1-4" href="#co_docker_CO1-4"><img src="callouts/4.png" alt="4"/></a></dt>
<dd><p>We call the container we are going to create <code>ac-nginx</code> for <em>Ansible Conductor Nginx</em>.</p></dd>
<dt><a class="co" id="callout_docker_CO1-5" href="#co_docker_CO1-5"><img src="callouts/5.png" alt="5"/></a></dt>
<dd><p>We specify <code>nginx</code> as the base image.</p></dd>
<dt><a class="co" id="callout_docker_CO1-6" href="#co_docker_CO1-6"><img src="callouts/6.png" alt="6"/></a></dt>
<dd><p>We need to specify the command that will be run when the container starts up.</p></dd>
<dt><a class="co" id="callout_docker_CO1-7" href="#co_docker_CO1-7"><img src="callouts/7.png" alt="7"/></a></dt>
<dd><p>We specify the roles to be used to configure this image. For this case,
there&#8217;s only one role, <code>ghost-nginx</code>.</p></dd>
<dt><a class="co" id="callout_docker_CO1-8" href="#co_docker_CO1-8"><img src="callouts/8.png" alt="8"/></a></dt>
<dd><p>The <code>registries</code> field is used to specify the external registries we will
push our containers to. We haven&#8217;t configured this yet, so it&#8217;s blank.</p></dd>
</dl>
<div data-type="warning">
<p>Ansible Container does not automatically pull base images to your local
machine.<a data-type="indexterm" data-primary="Nginx" data-secondary="pulling base Nginx image for ac-nginx container"/> You must do that yourself before building the containers. For example,
before you run <a data-type="xref" href="#container.yml"/>, you would need to pull the <code>nginx</code> base image
that is required to build <span class="keep-together"><code>ac-nginx</code></span>:</p>

<pre data-type="programlisting">$ docker pull nginx</pre>
</div>
</section>













<section data-type="sect3">
<h3>Building the containers</h3>

<p>Finally, we&#8217;re<a data-type="indexterm" data-primary="Ansible Container" data-secondary="creating Docker images" data-tertiary="building containers"/><a data-type="indexterm" data-primary="ansible-container build command"/><a data-type="indexterm" data-primary="containers" data-secondary="building in Ansible Container"/> ready to build:</p>

<pre data-type="programlisting">$ ansible-container build</pre>

<p>The output should look like this:</p>

<pre data-type="programlisting">Building Docker Engine context...
Starting Docker build of Ansible Container Conductor image (please be patient)...
Parsing conductor CLI args.
Docker™ daemon integration engine loaded. Build starting.	project=ans-con
Building service...	project=ans-con service=ac-nginx

PLAY [ac-nginx] ****************************************************************

TASK [Gathering Facts] *********************************************************
ok: [ac-nginx]

TASK [ghost-nginx : remove default config] *************************************
changed: [ac-nginx]

TASK [ghost-nginx : add ghost config] ******************************************
changed: [ac-nginx]

PLAY RECAP *********************************************************************
ac-nginx                   : ok=3    changed=2    unreachable=0    failed=0

Applied role to service	role=ghost-nginx service=ac-nginx
Committed layer as image    image=sha256:5eb75981fc5117b3fca3207b194f3fa6c9ccb85
7718f91d674ec53d86323ffe3 service=ac-nginx
Build complete.	service=ac-nginx
All images successfully built.
Conductor terminated. Cleaning up.  command_rc=0 conductor_id=8c68ca4720beae5d9c
7ca10ed70a3c08b207cd3f68868b3670dcc853abf9b62b save_container=False</pre>

<p>Ansible Container uses a <code>{project}-{service}</code> convention for naming Docker
images; the project name is determined by the directory where you run
<code>ansible-container init</code>.
In my case, the directory is named <em>ans-con</em>, so the image that will be created
will be named <em>ans-con-ac-nginx</em>.</p>

<p>Ansible will also always create a conductor image, named <code>{project}-conductor</code>.</p>

<p>If you don&#8217;t want Ansible Container to use the directory name as the project
name, you can specify a custom project name by passing the <code>--project-name</code> flag.</p>

<p>If we run the following:</p>

<pre data-type="programlisting">$ docker images</pre>

<p>we&#8217;ll see the following new container images:</p>

<pre data-type="programlisting">REPOSITORY         TAG            IMAGE ID      CREATED        SIZE
ans-con-ac-nginx   20170424035545 5eb75981fc51  2 minutes ago  182 MB
ans-con-ac-nginx   latest         5eb75981fc51  2 minutes ago  182 MB
ans-con-conductor  latest         742cf2e046a3  2 minutes ago  622 MB</pre>
</section>













<section data-type="sect3">
<h3>Troubleshooting builds</h3>

<p>If the build command fails with an error, you can learn more by viewing the logs
generated by the Conductor container.<a data-type="indexterm" data-primary="Ansible Container" data-secondary="creating Docker images" data-tertiary="troubleshooting builds"/><a data-type="indexterm" data-primary="containers" data-secondary="building in Ansible Container" data-tertiary="troubleshooting builds"/> There are two ways to see the log.</p>

<p>One way is to use the <code>--debug</code> flag when invoking <code>ansible-container</code>.</p>

<p>If you don&#8217;t want to rerun with the <code>--debug</code> flag, you can get the log output from Docker. To
get it, you need to get the ID of the Conductor container. Because the
container will no longer be running, use the <code>ps -a</code> Docker command to find the
ID of the exited container:</p>

<pre data-type="programlisting">$ docker ps -a
CONTAINER ID  IMAGE         COMMAND                  CREATED         STATUS
78e78b9a1863  0c238eaf1819  "/bin/sh -c 'cd /_..."   21 minutes ago  Exited (1)</pre>

<p>Once you have the ID, you can view the log output like this:</p>

<pre data-type="programlisting">$ docker logs 78e78b9a1863</pre>
</section>



</section>













<section data-type="sect2">
<h2>Running Locally</h2>

<p>Ansible Container allows you to run multiple containers locally, just like
Docker Compose.<a data-type="indexterm" data-primary="Docker" data-secondary="Ansible Container" data-tertiary="creating Docker images" data-startref="ix_DockACimg"/><a data-type="indexterm" data-primary="Ansible Container" data-secondary="creating Docker images" data-startref="ix_AnsContimg"/> The <em>container.yml</em> file is similar to the format
of <em>docker-compose.yml</em>. We&#8217;ll extend our <em>container.yml</em> so that it behaves
the same way as <a data-type="xref" href="#docker-compose.yml"/>.<a data-type="indexterm" id="ix_DockACloc" data-primary="Docker" data-secondary="Ansible Container" data-tertiary="running locally"/><a data-type="indexterm" id="ix_AnsContlocal" data-primary="Ansible Container" data-secondary="running locally"/> This is shown in
<a data-type="xref" href="#container.yml-local"/>.</p>
<div id="container.yml-local" data-type="example">
<h5>container.yml, configured for local execution</h5>

<pre data-type="programlisting">version: "2"
settings:
  conductor_base: debian:jessie
services:
  ac-nginx:
    from: nginx
    command: [nginx, -g, daemon off;]
    roles:
      - ghost-nginx
    ports:
      - "8443:443"
      - "8000:80"
    dev_overrides:  <a class="co" id="co_docker_CO2-1" href="#callout_docker_CO2-1"><img src="callouts/1.png" alt="1"/></a>
      volumes:
        - $PWD/certs:/certs
      links:
        - ghost
  ghost: <a class="co" id="co_docker_CO2-2" href="#callout_docker_CO2-2"><img src="callouts/2.png" alt="2"/></a>
    from: ghost
    dev_overrides:
      volumes:
        - $PWD/ghostdata:/var/lib/ghost
registries: {}</pre></div>

<p>Note the changes from <a data-type="xref" href="#container.yml"/> to <a data-type="xref" href="#container.yml-local"/>:</p>
<dl class="calloutlist">
<dt><a class="co" id="callout_docker_CO2-1" href="#co_docker_CO2-1"><img src="callouts/1.png" alt="1"/></a></dt>
<dd><p>We&#8217;ve added a <code>dev_overrides</code> section to the <code>ac-nginx</code> service that
contains data that is specific for running locally (i.e., not used for creating
images or for deploying to production). For this service, that involves
mounting the TLS certificates from the local filesystem and linking the
container to the <code>ghost</code> container.</p></dd>
<dt><a class="co" id="callout_docker_CO2-2" href="#co_docker_CO2-2"><img src="callouts/2.png" alt="2"/></a></dt>
<dd><p>We&#8217;ve added a <code>ghost</code> service that contains the Ghost app. We didn&#8217;t need
this previously because we aren&#8217;t creating a custom Ghost container; we&#8217;re just
running the official one unmodified.</p></dd>
</dl>

<p>Note that while the syntax is similar to Docker Compose, it isn&#8217;t identical.
For example, Ansible Container uses <code>from</code>, whereas Docker Compose uses <code>image</code>,
and Docker Compose does not have a <code>dev_overrides</code> section.</p>

<p>You can start the containers on your local machine by doing this:</p>

<pre data-type="programlisting">$ ansible-container run</pre>

<p class="pagebreak-before">You can stop them as follows:</p>

<pre data-type="programlisting">$ ansible-container stop</pre>

<p>If you want to stop all containers and delete all images that you&#8217;ve created, use the following:</p>

<pre data-type="programlisting">$ ansible-container destroy</pre>
</section>













<section data-type="sect2">
<h2>Publishing Images to Registries</h2>

<p>Once you are satisfied with your images, you&#8217;ll want to publish them to a
registry so that you can deploy them.<a data-type="indexterm" data-primary="Docker" data-secondary="Ansible Container" data-tertiary="running locally" data-startref="ix_DockACloc"/><a data-type="indexterm" data-primary="Ansible Container" data-secondary="running locally" data-startref="ix_AnsContlocal"/><a data-type="indexterm" data-primary="images (Docker)" data-secondary="publishing to registries using Ansible Container"/><a data-type="indexterm" data-primary="Ansible Container" data-secondary="publishing images to registries"/><a data-type="indexterm" data-primary="Docker" data-secondary="Ansible Container" data-tertiary="publishing images to registries"/></p>

<p>You&#8217;ll need to configure the registries section of <a data-type="xref" href="#container.yml"/> to specify a
registry. For example, <a data-type="xref" href="#registries"/> shows how to configure
<em>container.yml</em> to push images to the <em>ansiblebook</em> organization in the Docker
registry.</p>
<div id="registries" data-type="example">
<h5>registries section of container.yml</h5>

<pre data-type="programlisting">registries:
  docker:
    url: https://index.docker.io/v1/
    namespace: ansiblebook</pre></div>










<section data-type="sect3">
<h3>Authenticating</h3>

<p>The first time you push your image, you need to pass your username as a
command-line<a data-type="indexterm" data-primary="Ansible Container" data-secondary="publishing images to registries" data-tertiary="authenticating"/> argument:</p>

<pre data-type="programlisting">$ ansible-container push --username $YOUR_USERNAME</pre>

<p>You&#8217;ll be prompted to enter your password.  The first time you push an image, Ansible Container stores your credentials
in <em>~/.docker/config.json</em>, and on subsequent pushes you don&#8217;t need to specify
a username or password anymore.</p>

<p>The output looks like this:</p>

<pre data-type="programlisting">Parsing conductor CLI args.
Engine integration loaded. Preparing push.	engine=Docker™ daemon
Tagging ansiblebook/ans-con-ac-nginx
Pushing ansiblebook/ans-con-ac-nginx:20170430055647...
The push refers to a repository [docker.io/ansiblebook/ans-con-ac-nginx]
Preparing
Pushing
Mounted from library/nginx
Pushed
20170430055647: digest: sha256:50507495a9538e9865fe3038d56793a1620b9b372482667a
Conductor terminated. Cleaning up.  command_rc=0 conductor_id=1d4cfa04a055c1040</pre>
</section>













<section data-type="sect3">
<h3>Multiple registries</h3>

<p>Ansible Container allows you to specify multiple registries.<a data-type="indexterm" data-primary="Ansible Container" data-secondary="publishing images to registries" data-tertiary="multiple registries"/><a data-type="indexterm" data-primary="registry (Docker images)" data-secondary="publishing images to multiple registries"/> For example, here
is a <code>registries</code> section that has two registries, Docker Hub and Quay:</p>

<pre data-type="programlisting">registries:
  docker:
    namespace: ansiblebook
    url: https://index.docker.io/v1/
  quay:
    namespace: ansiblebook
    url: https://quay.io</pre>

<p>To push images to only one of the registries, use the <code>--push-to</code> flag. For
example, this pushes to the Quay registry:</p>

<pre data-type="programlisting">$ ansible-container push --push-to quay</pre>
</section>



</section>













<section data-type="sect2">
<h2>Deploying Containers to Production</h2>

<p>Although we don&#8217;t cover it here, Ansible Container also has support for
deploying your containers to a production environment, using the
<code>ansible-container deploy</code> command. <a data-type="indexterm" data-primary="Ansible Container" data-secondary="deploying containers to production"/><a data-type="indexterm" data-primary="Docker" data-secondary="Ansible Container" data-tertiary="deploying containers to production"/>As of this writing, Ansible Container
has support for deploying to two container management platforms:
OpenShift and Kubernetes.</p>

<p>If you are looking for an Ansible Container-supported public cloud for running your containers,<a data-type="indexterm" data-primary="cloud" data-secondary="Ansible Container-supported public clouds"/> Red Hat
operates an OpenShift-based cloud platform called OpenShift Online, and Google
provides Kubernetes as part of its Google Compute Engine cloud platform.<a data-type="indexterm" data-primary="Kubernetes"/><a data-type="indexterm" data-primary="OpenShift"/> Both
platforms are also open source, so if you manage your own hardware, you can
deploy either OpenShift or Kubernetes on them for free. If you want to deploy on another platform (e.g.,
EC2 Container Service or Azure Container Service), you won&#8217;t be able to
use Ansible Container for the deployment.<a data-type="indexterm" data-primary="Docker" data-secondary="Ansible Container" data-startref="ix_DockAC"/><a data-type="indexterm" data-primary="Ansible Container" data-startref="ix_AnsCont"/></p>

<p>Docker as a technology has clearly demonstrated that it has staying power. In
this chapter, we covered how to manage Docker images, containers, and networks.
While we weren&#8217;t able to cover the creation of Docker images with Ansible
playbooks, by the time you read this, you&#8217;ll likely be able to use Ansible
playbooks for creating images as well.<a data-type="indexterm" data-primary="Ghost" data-secondary="deploying Dockerized application" data-startref="ix_Ghostdep"/><a data-type="indexterm" data-primary="Docker" data-secondary="deploying Dockerized application" data-startref="ix_Dockdep"/><a data-type="indexterm" data-primary="Docker" data-startref="ix_Dock"/></p>
</section>





</section>







</section>
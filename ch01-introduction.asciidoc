[[introduction]]

[role="pagenumrestart"]
== Introduction

It's an interesting time to be working in the IT industry. We don't deliver software to our customers by installing a program on a single machine and calling it a day.footnote:[OK, nobody ever really delivered software like that.] Instead, we are all slowly turning into system engineers.

We now deploy software applications by stringing together services that run on a
pass:[<span class="keep-together">distributed</span>] set of computing resources and communicate over different networking
protocols.  A typical application can include web servers, application servers,
memory-based caching systems, task queues, message queues, SQL databases, NoSQL
datastores, and load balancers.

We also need to make sure we have the
appropriate redundancies  in place, so that when failures happen (and they will),
our software systems will handle these failures gracefully.  Then there are the secondary services that we also need to deploy and maintain, such as logging,
monitoring, and analytics, as well as third-party services we need to interact
with, such as infrastructure-as-a-service (IaaS) endpoints for managing virtual machine
instances.footnote:[Check out <<cloudsysadmin,_The Practice of Cloud System Administration_>> and <<dataintensive,_Designing Data-Intensive Applications_>> for
excellent books on building and maintaining these types of distributed systems.]

You can wire up these services by hand: spinning up the servers you need,
SSHing to each one, installing packages, editing config files, and so forth,
but it's a pain. It's time-consuming, error-prone, and just plain dull to do
this kind of work manually, especially around the third or fourth time. And for
more complex tasks, like standing up an OpenStack cloud inside your application,
doing it by hand is madness. There's a better way.

If you're reading this, you're probably already sold on the idea of
configuration management and considering adopting Ansible as your configuration
management tool. Whether you're a developer deploying your code to production,
or you're a systems administrator looking for a better way to automate,
I think you'll find Ansible to be an excellent solution to
your problem.

=== A Note About Versions

The example code in this book was tested against version 2.3.0.0 of
Ansible, which is the most recent release as of this writing.((("Ansible", "versions")))  As backward compatibility is a major goal of the Ansible project, these examples should work unmodified in future versions of Ansible.

.What's with the Name _Ansible_?
****
It's a science-fiction reference. An _ansible_ is a fictional communication
device that can transfer information faster than the speed of light. Ursula K. Le Guin invented the concept in her book _Rocannon's World_, and other
sci-fi authors have since borrowed the idea from Le Guin.

More specifically, Michael DeHaan took the name Ansible from the book _Ender's
Game_ by Orson Scott Card. In that book, the ansible was used to control many remote ships at once, over vast distances. Think of it as a metaphor
for controlling remote servers.

****

=== Ansible: What Is It Good For?

Ansible is often described as a _configuration management_ tool, and is
typically mentioned in the same breath as _Chef_, _Puppet_, and _Salt_.((("configuration management tools")))((("Ansible", "uses of")))  When we
talk about configuration management, we are typically talking about writing some
kind of state description for our servers, and then using a tool to enforce that
the servers are, indeed, in that state: the right packages are installed,
configuration files contain the expected values and have the expected
permissions, the right services are running, and so on.((("configuration management"))) Like other configuration
management tools, Ansible exposes a domain-specific language (DSL) that you use
to describe the state of your servers.


These tools can be used for _deployment_ as well.((("deployment, tools for"))) When people talk about deployment, they are usually referring to the process of taking software
that was written in-house, generating binaries or static assets (if necessary),
copying the required files to the server(s), and then starting up the services.
_Capistrano_ and _Fabric_ are two examples of open source deployment tools.
Ansible is a great tool for deployment as well as configuration
management. Using a single tool for both configuration management and deployment
makes life simpler for the folks responsible for operations.

Some people talk about the need for _orchestration_ of deployment.((("orchestration of deployment"))) This is
where multiple remote servers are involved, and things have to happen in a
specific order. For example, you need to bring up the database before bringing
up the web servers, or you need to take web servers out of the load balancer one
at a time in order to upgrade them without downtime. Ansible is good at this as
well, and is designed from the ground up for performing actions on multiple
servers. Ansible has a refreshingly simple model for controlling the order in which
actions happen.

Finally, you'll hear people talk about _provisioning_ new servers.((("provisioning servers")))((("cloud", "Ansible modules for talking to public cloud services"))) In the context of public clouds such as Amazon EC2, this refers to spinning up a new virtual machine instance. Ansible has got you covered here, with a number of modules for talking to clouds, including EC2, Azure, Digital Ocean, Google Compute Engine, Linode, and Rackspace, as well as any clouds that support the OpenStack APIs.

[NOTE]
====
Confusingly, the _Vagrant_ tool, covered later in this chapter, uses
the term _provisioner_ to refer to a tool that does the configuration
management.((("provisioners"))) So, Vagrant refers to Ansible as a kind of provisioner, whereas I
think of Vagrant as a provisioner, since Vagrant is responsible for
starting up virtual machines.
====

=== How Ansible Works

<<overview_figure>> shows a sample use case of Ansible in action. A user we'll call Stacy is using Ansible to configure three Ubuntu-based web servers to run Nginx.((("Ansible", "how it works"))) She has written an Ansible script called _webservers.yml_.((("playbooks"))) In Ansible, a script is called a _playbook_.((("hosts")))((("remote servers"))) A playbook describes which _hosts_ (what Ansible calls _remote servers_) to configure, and an ordered list of _tasks_ to perform on those hosts.((("tasks"))) In this example, the hosts are web1, web2, and web3, and the tasks are things such as these:

* Install Nginx
* Generate an Nginx configuration file
* Copy over the security certificate
* Start the Nginx service

In the next chapter, we'll discuss what's in this playbook.  Stacy executes the playbook by using the `ansible-playbook` command. In the example, the playbook is named _webservers.yml_, and is executed by typing the following:

----
$ ansible-playbook webservers.yml
----

Ansible will make SSH connections in parallel to web1, web2, and web3. It will execute the first task on the list on all three hosts simultaneously. In this example, the first task is installing the Nginx apt package (since Ubuntu uses the apt package manager), so the task in the playbook would look something like this:

[source,yaml]
----
- name: Install nginx
  apt: name=nginx
----

Ansible will do the following:

. Generate a Python script that installs the Nginx package
. Copy the script to web1, web2, and web3
. Execute the script on web1, web2, and web3
. Wait for the script to complete execution on all hosts

Ansible will then move to the next task in the list, and go through these same
four steps. It's important to note the following:

* Ansible runs each task in parallel across all hosts.
* Ansible waits until all hosts have completed a task before moving to the
  next task.
* Ansible runs the tasks in the order that you specify them.


[[overview_figure]]
.Running an Ansible playbook to configure three web servers
image::images/aur2_0101.png["Overview of Ansible behavior"]

[role="pagebreak-before"]
=== What's So Great About Ansible?

There are several open source configuration management tools out there to choose
from.((("Ansible", "advantages of", id="ix_Ansadv"))) Here are some of the things that drew me to Ansible.


==== Easy-to-Read Syntax

Recall that Ansible configuration management scripts are called _playbooks_.
Ansible's playbook syntax is built on top of YAML, ((("playbooks", "easy-to-read syntax")))which is a data format
language that was designed to be easy for humans to read and write.((("YAML"))) In a way, YAML is
to JSON what Markdown is to HTML.

I like to think of Ansible playbooks as _executable documentation_. It's like
the README file that describes the commands you had to type
out to deploy your software, except that the instructions will never go out-of-date
because they are also the code that gets executed directly.

==== Nothing to Install on the Remote Hosts

To manage a server with Ansible, the server needs to have SSH and
Python 2.5 or later installed, or Python 2.4 with the Python _simplejson_
library installed.((("SSH")))((("Python", "Python 2.5 or later"))) There's no need to preinstall an agent or any
other software on the host.

The control machine (the one that you use to control remote machines) needs to
have Python 2.6 or later installed.

[TIP]
====
Some modules might require Python 2.5 or later, and some might have additional prerequisites. Check the documentation for each module to see whether it has specific requirements.
====


==== Push Based

Some configuration management systems that use agents, such as Chef and Puppet, are _pull based_ by default.((("pull based configuration management systems"))) Agents installed on the servers periodically check in with a central service and pull down configuration information from the service. Making configuration management changes to servers goes something like this:

. You: make a change to a configuration management script.
. You: push the change up to a configuration management central service.
. Agent on server: wakes up after periodic timer fires.
. Agent on server: connects to configuration management central service.
. Agent on server: downloads new configuration management scripts.
. Agent on server: executes configuration management scripts locally that change server state.

In contrast, Ansible is _push based_ by default.((("push based (Ansible)"))) Making a change looks like
this:

. You: make a change to a playbook.
. You: run the new playbook.
. Ansible: connects to servers and executes modules, which changes server state.

As soon as you run the +ansible-playbook+ command, Ansible connects to the
remote server and does its thing.((("ansible-playbook command")))

The push-based approach has a significant advantage: you control when the
changes happen to the servers. You don't need to wait around for a timer
to expire. Advocates of the pull-based approach claim that pull is superior for
scaling to large numbers of servers and for dealing with new servers that can come online
anytime. However, as we'll discuss later in the book, Ansible has been used
successfully in production with thousands of nodes, and has excellent support
for environments where servers are dynamically added and removed.

If you really prefer using a pull-based model, Ansible has official support for pull mode, using a tool it ships with called _ansible-pull_. ((("ansible-pull tool")))I don't cover pull mode in this book, but you can read more about it in the http://docs.ansible.com/playbooks_intro.html#ansible-pull[official documentation].

==== Ansible Scales Down

Yes, Ansible can be used to manage hundreds or even thousands of
nodes.((("scaling", "scaling down with Ansible"))) But what got me hooked is how it scales down. Using Ansible to
configure a single node is easy; you simply write a single playbook. Ansible obeys Alan Kay's maxim: "Simple things should be simple; complex things should be possible."


==== Built-in Modules

You can use Ansible to execute arbitrary shell commands on your remote servers, but Ansible's real power comes from the collection of modules it ships with.((("modules", "built-in, with Ansible"))) You use modules to perform tasks such as installing a package, restarting a service, or copying a configuration file.

As you'll see later, Ansible modules are _declarative_; you use them to describe
the state you want the server to be in. For example, you would invoke the user
module like this to ensure there was an account named `deploy` in the `web`
group:

----
user: name=deploy group=web
----

Modules are also _idempotent_. If the `deploy` user doesn't exist, Ansible will
create it.((("idempotence", "Ansible modules"))) If it does exist, Ansible won't do anything. Idempotence is a
nice property because it means that it's safe to run an Ansible playbook
multiple times against a server. This is a big improvement over the homegrown
shell script approach, where running the shell script a second time might have a different
(and likely unintended) effect.

.What About Convergence?
****
Books on configuration management often mention the concept of _convergence_. Convergence in configuration management is most closely associated with Mark Burgess and the _CFEngine_ configuration management system he authored.((("convergence"))) If a configuration management system is convergent, the system may
run multiple times to put a server into its desired state, with each run bringing
the server closer to that state.

This idea of convergence doesn't really apply to Ansible, as Ansible doesn't
have a notion of running multiple times to configure servers. Instead, Ansible modules are
implemented in such a way that running an Ansible playbook a single time should
put each server into the desired state.

If you're interested in what Ansible's author thinks of the
idea of convergence, see http://bit.ly/1InGh1A[Michael DeHaan's post] in the Ansible Project newsgroup, titled "Idempotence, convergence, and other silly fancy words we use too often."
****

==== Very Thin Layer of Abstraction

Some configuration management tools provide a layer of abstraction so
that you can use the same configuration management scripts to manage servers
running different operating systems.((("abstraction, thin layer of"))) For example, instead of having to deal with
a specific package manager like yum or apt, the configuration management tool
exposes a "package" abstraction that you use instead.

Ansible isn't like that.((("apt module")))((("yum module"))) You have to use the apt module to install packages on
apt-based systems and the yum module to install packages on yum-based systems.

Although this might sound like a disadvantage, in practice I've found that
it makes Ansible easier to work with. Ansible doesn't require that I learn a new
set of abstractions that hide the differences between operating systems.
This makes Ansible's surface area smaller; there's less you need to know before
you can start writing playbooks.

If you really want to, you can write your Ansible playbooks to take different
actions, depending on the operating system of the remote server. But I try to
avoid that when I can, and instead I focus on writing playbooks that are designed
to run on a specific operating system, such as Ubuntu.

The primary unit of reuse in the Ansible community is the module.((("modules", "primary unit of reuse in Ansible"))) Because the
scope of a module is small and can be operating-system specific, it's
straightforward to implement well-defined, shareable modules. The Ansible
project is very open to accepting modules contributed by the community. I know because I've contributed a few.

Ansible playbooks aren't really intended to be reused across different contexts.((("playbooks", "reuse of")))
In <<roles>>, we'll discuss _roles_, which is a way of collecting
playbooks together so they are more reusable, as well as Ansible
Galaxy, which is an online repository of these roles.((("roles")))

In practice, though, every organization sets up its servers a little bit
differently, and you're best off writing playbooks for your organization rather
than trying to reuse generic playbooks. I believe the primary value of looking at other
people's playbooks is for examples to see how things are done.


.What Is Ansible, Inc.'s Relationship to Ansible?
****
The name _Ansible_ refers to both the software and the company that runs the open source project. Michael DeHaan, the creator of Ansible the software, is the former CTO of Ansible the company. To avoid confusion, I refer to the software as _Ansible_ and to the company as _Ansible, Inc_.((("Ansible, Inc.")))

Ansible, Inc. sells training and consulting services for Ansible, as well as a proprietary web-based management tool called _Ansible Tower_, which is covered in
<<Ansible_Tower>>. In October 2015, Red Hat acquired Ansible, Inc.((("Ansible Tower")))((("Ansible", "advantages of", startref="ix_Ansadv")))

****

=== Is Ansible Too Simple?

When I was working on this book, my editor mentioned to me that "some folks who use the XYZ configuration management tool call Ansible a for-loop over SSH scripts." If you're considering switching over from another config
management tool, you might be concerned at this point about whether Ansible is powerful enough
to meet your needs.

As you'll soon learn, Ansible provides a lot more functionality than shell
scripts. As I mentioned, Ansible's modules provide idempotence, and Ansible has
excellent support for templating, as well as defining variables at different
scopes. Anybody who thinks Ansible is equivalent to working with shell scripts
has never had to maintain a nontrivial program written in shell. I'll always
choose Ansible over shell scripts for config management tasks if given a choice.

And if you're worried about the scalability of SSH? As we'll discuss in
<<custom_modules>>, Ansible uses SSH multiplexing to optimize performance, and there are
folks out there who are managing thousands of nodes with Ansible.footnote:[For example, see http://www.slideshare.net/JesseKeating/ansiblefest-rax["Using Ansible at Scale to Manage a Public Cloud"] by Jesse Keating, formerly of Rackspace.]

[NOTE]
====
I'm not familiar enough with the other tools to describe their
differences in detail. If you're looking for a head-to-head comparison of config management tools, check out <<tastetest,_Taste Test: Puppet, Chef, Salt, Ansible_>> by Matt Jaynes. As it happens, Matt prefers Ansible.
====

=== What Do I Need to Know?

To be productive with Ansible, you need to be familiar with basic Linux system administration tasks.((("Ansible", "prerequisites for"))) Ansible makes it easy to automate your tasks, but it's not the kind of tool that "automagically" does things that you otherwise wouldn't know how to do.

For this book, I assumed my readers would be ((("Linux distributions")))familiar with at least one Linux distribution (e.g., Ubuntu, RHEL/CentOS, SUSE), and that they would know how to

* Connect to a remote machine using SSH
* Interact with the Bash command-line shell (pipes and redirection)
* Install packages
* Use the +sudo+ command
* Check and set file permissions
* Start and stop services
* Set environment variables
* Write scripts (any language)

If these concepts are all familiar to you, you're good to go with Ansible.

I won't assume you have knowledge of any particular programming language. For instance, you don't need to know Python to use Ansible unless you want to write your own module.

Ansible uses the YAML file format and the Jinja2 templating languages, so
you'll need to learn some YAML and Jinja2 to use Ansible, but both technologies are
easy to pick up.((("YAML")))((("Jinja2 template engine")))

=== What Isn't Covered

This book isn't an exhaustive treatment of Ansible. It's designed to get you
productive in Ansible as quickly as possible and describes how to perform
certain tasks that aren't obvious from glancing over the official documentation.

I don't cover the official Ansible modules in detail. There are over 200
of these, and the official Ansible reference documentation on the modules is
quite good.

I cover only the basic features of the templating engine that Ansible uses,
Jinja2, primarily because I find that I generally need to use only those basic
features when I use Ansible. If you need to use more advanced Jinja2
features in your templates, I recommend you check out the official http://jinja.pocoo.org/docs/dev/[Jinja2 documentation].

I don't go into detail about some features of Ansible that are mainly useful
when you are running Ansible on an older version of Linux. This includes
features such as the _Paramiko_ SSH client and _accelerated mode_.

Finally, there are several features of Ansible I don't cover simply to keep the book a manageable length. These features include pull mode, logging, connecting to hosts using protocols other than SSH, and prompting the user for passwords or input. I encourage you to check out the official docs to find out more about these features.

=== Installing Ansible

If you're running on a Linux machine, all of the major Linux distributions package
Ansible these days, so you should be able to install it using your native
package manager, although this might be an older version of Ansible.((("Ansible", "installing")))
If you're running on macOS, I recommend you use the excellent Homebrew
package manager to install Ansible.((("Homebrew package manager")))

If all else fails, you can install it using _pip_, Python's package manager. You
can install it as root by running((("pip, installing Ansible with"))) the following:

----
$ sudo pip install ansible
----

If you don't want to install Ansible as root, you can safely install it into a Python
_virtualenv_.((("Python", "virtualenv")))((("virtualenv", "installing Ansible in"))) If you're not familiar with virtualenvs, you can use a newer tool
called _pipsi_ that will automatically ((("pipsi, installing Ansible with")))install Ansible into a virtualenv for you:

----
$ wget https://raw.githubusercontent.com/mitsuhiko/pipsi/master/get-pipsi.py
$ python get-pipsi.py
$ pipsi install ansible
----

If you go the pipsi route, you need to update your PATH environment
variable to include _~/.local/bin_.((("PATH environment variable"))) Some Ansible plugins and modules might require additional Python libraries. ((("Docker", "docker-py for Ansible Docker modules")))If you've installed with pipsi, and you want to install _docker-py_ (needed by the Ansible Docker modules) and _boto_ (needed by the Ansible EC2 modules), you ((("Boto library")))do it like this:

----
$ cd ~/.local/venvs/ansible
$ source bin/activate
$ pip install docker-py boto
----


If you're feeling adventurous and want to use the bleeding-edge version of Ansible, you can grab the development branch from GitHub:

----
$ git clone https://github.com/ansible/ansible.git --recursive
----

If you're running Ansible from the development branch,((("development branch, running Ansible from"))) you need to run these
commands each time to set up your environment variables, including your PATH
variable so that your shell knows where the _ansible_ and _ansible-playbooks_
programs are:

----
$ cd ./ansible
$ source ./hacking/env-setup
----

For more details on installation see these resources:

* http://docs.ansible.com/intro_installation.html[Official Ansible install docs]
* http://pip.readthedocs.org/[Pip]
* http://docs.python-guide.org/en/latest/dev/virtualenvs/[Virtualenv]
* https://github.com/mitsuhiko/pipsi[Pipsi]

=== Setting Up a Server for Testing

You need to have SSH access and root privileges on a Linux server to follow along with the examples in this book.((("test server for Ansible", id="ix_testser")))((("servers", "setting up a server for testing", id="ix_serversetup")))((("Linux", "low-cost access through cloud to virtual machine")))((("cloud", "low-cost access to Linux virtual machine"))) Fortunately, these days it's easy to get
low-cost access to a Linux virtual machine through a public cloud service such as
Amazon EC2, Google Compute Engine, Microsoft Azure,footnote:[Yes, Azure supports Linux servers.] Digital Ocean, Linode...you get the idea.

==== Using Vagrant to Set Up a Test Server

If you prefer not to spend the money on a public cloud, I recommend
you install Vagrant on your machine. Vagrant is an excellent open source tool for managing virtual machines.((("Vagrant", "setting up test server with", id="ix_Vagtestser"))) You can use Vagrant to boot a Linux virtual
machine inside your laptop, and you can use that as a test server.

Vagrant has built-in support for provisioning virtual machines with Ansible, but
we'll talk about that in detail in <<inventory>>. For now, we'll just manage a Vagrant
virtual machine as if it were a regular Linux server.

Vagrant needs the VirtualBox virtualizer to be installed on your machine.
Download http://www.virtualbox.org[VirtualBox] and then download http://www.vagrantup.com[Vagrant].((("VirtualBox virtualizer")))

I recommend you create a directory for your Ansible playbooks and related files. In the following example, I've named mine _playbooks_.

Run the following commands to create a Vagrant configuration file (Vagrantfile)
for ((("Ubuntu 14.04 virtual machine, setting up", id="ix_Ubuvm")))an Ubuntu 14.04 (Trusty Tahr) 64-bit virtual machine image,footnote:[Vagrant uses the term _machine_ to refer to a virtual machine and _box_ to refer to a virtual machine image.] and boot it:

[source,console]
----
$ mkdir playbooks
$ cd playbooks
$ vagrant init ubuntu/trusty64
$ vagrant up
----

[NOTE]
====
The first time you use +vagrant up+, it will download the virtual machine image file, which might take a while, depending on your internet connection.
====

If all goes well, the output should look like this:

----
Bringing machine 'default' up with 'virtualbox' provider...
==> default: Importing base box 'ubuntu/trusty64'...
==> default: Matching MAC address for NAT networking...
==> default: Checking if box 'ubuntu/trusty64' is up to date...
==> default: Setting the name of the VM: playbooks_default_1474348723697_56934
==> default: Clearing any previously set forwarded ports...
==> default: Clearing any previously set network interfaces...
==> default: Preparing network interfaces based on configuration...
    default: Adapter 1: nat
==> default: Forwarding ports...
    default: 22 (guest) => 2222 (host) (adapter 1)
==> default: Booting VM...
==> default: Waiting for machine to boot. This may take a few minutes...
    default: SSH address: 127.0.0.1:2222
    default: SSH username: vagrant
    default: SSH auth method: private key
    default: Warning: Remote connection disconnect. Retrying...
    default: Warning: Remote connection disconnect. Retrying...
    default:
    default: Vagrant insecure key detected. Vagrant will automatically replace
    default: this with a newly generated keypair for better security.
    default:
    default: Inserting generated public key within guest...
    default: Removing insecure key from the guest if it's present...
    default: Key inserted! Disconnecting and reconnecting using new SSH key...
==> default: Machine booted and ready!
==> default: Checking for guest additions in VM...
    default: The guest additions on this VM do not match the installed version
    default: of VirtualBox! In most cases this is fine, but in rare cases it can
    default: prevent things such as shared folders from working properly. If you
    default: see shared folder errors, please make sure the guest additions 
    default: within the virtual machine match the version of VirtualBox you have 
    default: installed on your host and reload your VM.
    default:
    default: Guest Additions Version: 4.3.36
    default: VirtualBox Version: 5.0
==> default: Mounting shared folders...
    default: /vagrant => /Users/lorin/dev/ansiblebook/ch01/playbooks
----

You should be able to SSH into your new Ubuntu 14.04 virtual machine by running the ((("SSH", "accessing Ubuntu 14.04 virtual machine with vagrant ssh")))((("vagrant ssh command")))following:

[source,console]
----
$ vagrant ssh
----

If this works, you should see a login screen like this:

----
Welcome to Ubuntu 14.04.5 LTS (GNU/Linux 3.13.0-96-generic x86_64)

 * Documentation:  https://help.ubuntu.com/

  System information as of Fri Sep 23 05:13:05 UTC 2016

  System load:  0.76              Processes:           80
  Usage of /:   3.5% of 39.34GB   Users logged in:     0
  Memory usage: 25%               IP address for eth0: 10.0.2.15
  Swap usage:   0%

  Graph this data and manage this system at:
    https://landscape.canonical.com/

  Get cloud support with Ubuntu Advantage Cloud Guest:
    http://www.ubuntu.com/business/services/cloud

0 packages can be updated.
0 updates are security updates.

New release '16.04.1 LTS' available.
Run 'do-release-upgrade' to upgrade to it.
----

Type **`exit`** to quit the SSH session.


This approach lets us interact with the shell, but Ansible needs to connect to the virtual machine by using the regular SSH client, not the +vagrant ssh+ command.((("vagrant ssh-config command")))((("SSH", "vagrant ssh-config command")))

Tell Vagrant to output the SSH connection details by typing the following:

[source,console]
----
$ vagrant ssh-config
----

On my machine, the output looks like this:

----
Host default
  HostName 127.0.0.1
  User vagrant
  Port 2222
  UserKnownHostsFile /dev/null
  StrictHostKeyChecking no
  PasswordAuthentication no
  IdentityFile /Users/lorin/dev/ansiblebook/ch01/playbooks/.vagrant/
  machines/default/virtualbox/private_key
  IdentitiesOnly yes
  LogLevel FATAL
----

The important lines are shown here:

----
  HostName 127.0.0.1
  User vagrant
  Port 2222
  IdentityFile /Users/lorin/dev/ansiblebook/ch01/playbooks/.vagrant/
  machines/default/virtualbox/private_key
----


[NOTE]
====
Vagrant 1.7 changed how it handled private SSH keys. Starting with 1.7, Vagrant generates a new private key for each machine. Earlier versions used the same key, which was in the default location of _~/.vagrant.d/insecure_private_key_. The examples in this book use Vagrant 1.7.
====

In your case, every field should likely be the same except for the path of the
identity file.

Confirm that you can start an SSH session from the command line by using this information. In my case, the SSH command is as follows:

[source,console]
----
$ ssh vagrant@127.0.0.1 -p 2222 -i /Users/lorin/dev/ansiblebook/ch01/
playbooks/.vagrant/machines/default/virtualbox/private_key
----


You should see the Ubuntu login screen. Type **`exit`** to quit the SSH session.((("Ubuntu 14.04 virtual machine, setting up", startref="ix_Ubuvm")))((("Vagrant", "setting up test server with")))


==== Telling Ansible About Your Test Server

Ansible can manage only the servers it explicitly knows about. You provide Ansible with information about servers by specifying them in an inventory file.((("test server for Ansible", "telling Ansible about the server")))

Each server needs a name that Ansible will use to identify it. You can use the
hostname of the server, or you can give it an alias and pass additional
arguments to tell Ansible how to connect to it. We'll give our Vagrant server the alias of +testserver+.

Create a file called _hosts_ in the _playbooks_ directory. This file will serve as the inventory file. If you're using a Vagrant machine as your test server, your _hosts_ file should look like <<FIRST_INVENTORY>>.  I've broken up the file content across multiple lines so that it fits on the page, but it should be all on one line in your file, without any backslashes.

[[FIRST_INVENTORY]]
.playbooks/hosts
====
----
testserver ansible_host=127.0.0.1 ansible_port=2222 \
 ansible_user=vagrant \
 ansible_private_key_file=.vagrant/machines/default/virtualbox/private_key
----
====

Here we see one of the drawbacks of using Vagrant: we have to explicitly pass in
extra arguments to tell Ansible how to connect. In most cases, we won't need this extra data.

Later in this chapter, you'll see how to use the _ansible.cfg_ file to avoid
having to be so verbose in the inventory file. In later chapters, you'll see how
to use Ansible variables to similar effect.

If you have an Ubuntu machine on Amazon EC2 with a hostname like
+ec2-203-0-113-120.compute-1.amazonaws.com+, then your inventory file will look
something like this (all on one line):

----
testserver ansible_host=ec2-203-0-113-120.compute-1.amazonaws.com \
 ansible_user=ubuntu ansible_private_key_file=/path/to/keyfile.pem
----

[TIP]
====
Ansible supports the ssh-agent program, so you don't need to explicitly specify SSH key files in ((("SSH", "private keys")))((("ssh-agent")))your inventory files. See <<SSH_AGENT>> for more details if you haven't used ssh-agent before.
==== 

We'll use the +ansible+ command-line tool to verify that we can use Ansible to connect to the server. ((("ansible command")))You won't use the +ansible+ command often; it's mostly used for ad hoc, one-off things.

Let's tell Ansible to connect to the server named +testserver+ described in the inventory file named _hosts_ and((("ping module, invoking"))) invoke the +ping+ module:

----
$ ansible testserver -i hosts -m ping
----

If your local SSH client has host-key verification enabled, you might see something that looks like this the first time Ansible tries to connect to the server:

----
The authenticity of host '[127.0.0.1]:2222 ([127.0.0.1]:2222)' \
can't be established.
RSA key fingerprint is e8:0d:7d:ef:57:07:81:98:40:31:19:53:a8:d0:76:21.
Are you sure you want to continue connecting (yes/no)?
----

You can just type **`yes`**.

If it succeeded, output will look like this:

[role="pagebreak-before"]
----
testserver | success >> {
    "changed": false,
    "ping": "pong"
}
----

[TIP]
====
If Ansible did not succeed, add the +-vvvv+ flag to((("ansible command", "-vvvv flag"))) see more details about the error:

[source,console]
----
$ ansible testserver -i hosts -m ping -vvvv
----
====

We can see that the module succeeded. The +"changed": false+ part of the
output tells us that executing the module did not change the state of the server. The +"ping": "pong"+ text is output that is specific to the `ping` module.

The `ping` module doesn't do anything other than check that Ansible can
start an SSH session with the servers. It's a useful tool for testing that Ansible
can connect to the server.

==== Simplifying with the ansible.cfg File

We had to type a lot of text in the inventory file to tell Ansible about our
test server.((("test server for Ansible", "simplifying with ansible.cfg file"))) Fortunately, Ansible has ways to specify
these sorts of variables so we don't have to put them all in one place. Right now, we'll use one such mechanism, the _ansible.cfg_ file, to set some
defaults so we don't need to type as much.

.Where Should I Put My ansible.cfg File?
****
Ansible looks for an _ansible.cfg_ file in the following places, in this order:

. File specified by the +ANSIBLE_CONFIG+ environment variable
. _./ansible.cfg_ (_ansible.cfg_ in the current directory)
. _~/.ansible.cfg_ (_.ansible.cfg_ in your home directory)
. _/etc/ansible/ansible.cfg_

I typically put _ansible.cfg_ in the current directory, alongside my
playbooks. That way, I can check it into the same version-control repository that my
playbooks are in.
****


<<EX_CONFIG>> shows an _ansible.cfg_ file that specifies the location of
the inventory file (`inventory`), the user to SSH (`remote_user`), and the SSH
private key (+private_&#x200b;key_file+). This assumes you're using Vagrant. If you're using your own server, you'll need to set the `remote_user` and `private_key_file`
values accordingly.

Our example configuration also disables SSH host-key checking.((("SSH", "host-key checking, disabling"))) This is convenient
when dealing with Vagrant machines; otherwise, we need to edit our
_~/.ssh/known_hosts_ file every time we destroy and re-create a Vagrant machine.
However, disabling host-key checking can be a security risk when connecting to
other servers over the network. If you're not familiar with host keys, they are
covered in detail in <<Appendix>>.

[[EX_CONFIG]]
.ansible.cfg
====
[source,ini]
----
[defaults]
inventory = hosts
remote_user = vagrant
private_key_file = .vagrant/machines/default/virtualbox/private_key
host_key_checking = False
----
====

.Ansible and Version Control
****
Ansible uses _/etc/ansible/hosts_ as the default location for the inventory
file. However, I never use this because I like to keep my inventory files
version-controlled alongside my playbooks.

Although we don't cover the topic of version control in this book, I strongly
recommend you use a version-control system such as Git for maintaining all of your
playbooks. If you're a developer, you're already familiar with version-control
systems. If you're a systems administrator and aren't using version control yet,
this is a perfect opportunity to get started.
****

With our default values set, we no longer need to specify the SSH user or key
file in our _hosts_ file. Instead, it simplifies to the following:

----
testserver ansible_host=127.0.0.1 ansible_port=2222
----

We can also invoke Ansible without passing the +-i hostname+ arguments, like so:

[source,console]
----
$ ansible testserver -m ping
----

I like to use the `ansible` command-line tool to run arbitrary commands on remote machines, like parallel SSH. You can execute arbitrary commands with the
`command` module.((("ansible command", "invoking command module")))((("command module"))) When invoking this module, you also need to pass an argument
to the module with the +-a+ flag, which is the command to run.

For example, to check the uptime of our server, we can use this:

[source,console]
----
$ ansible testserver -m command -a uptime
----

Output should look like this:

----
testserver | success | rc=0 >>
 17:14:07 up  1:16,  1 user,  load average: 0.16, 0.05, 0.04
----

The `command` module is so commonly used that it's the default module, so we can
omit it:

[source,console]
----
$ ansible testserver -a uptime
----


If our command contains spaces, we need to quote it so that the shell passes the entire string as a single argument to Ansible.((("&quot;&quot; (double quotes), enclosing command text containing spaces"))) For example, to view the last several lines of the _/var/log/dmesg_ logfile:
[source,console]
----
$ ansible testserver -a "tail /var/log/dmesg"
----

The output from my Vagrant machine looks like this:

----
testserver | success | rc=0 >>
[    5.170544] type=1400 audit(1409500641.335:9): apparmor="STATUS" operation=
"profile_replace" profile="unconfined" name="/usr/lib/NetworkManager/nm-dhcp-c
lient.act on" pid=888 comm="apparmor_parser"
[    5.170547] type=1400 audit(1409500641.335:10): apparmor="STATUS" operation=
"profile_replace" profile="unconfined" name="/usr/lib/connman/scripts/dhclient-
script" pid=888 comm="apparmor_parser"
[    5.222366] vboxvideo: Unknown symbol drm_open (err 0)
[    5.222370] vboxvideo: Unknown symbol drm_poll (err 0)
[    5.222372] vboxvideo: Unknown symbol drm_pci_init (err 0)
[    5.222375] vboxvideo: Unknown symbol drm_ioctl (err 0)
[    5.222376] vboxvideo: Unknown symbol drm_vblank_init (err 0)
[    5.222378] vboxvideo: Unknown symbol drm_mmap (err 0)
[    5.222380] vboxvideo: Unknown symbol drm_pci_exit (err 0)
[    5.222381] vboxvideo: Unknown symbol drm_release (err 0)

----

If we need root access, we pass in the +-b+ flag to tell Ansible to _become_ the root user.((("root user"))) For example, accessing _/var/log/syslog_ requires root access:
[source,console]
----
$ ansible testserver -b -a "tail /var/log/syslog"
----

The output looks something like this:

----
testserver | success | rc=0 >>
Aug 31 15:57:49 vagrant-ubuntu-trusty-64 ntpdate[1465]: /
adjust time server 91.189
94.4 offset -0.003191 sec
Aug 31 16:17:01 vagrant-ubuntu-trusty-64 CRON[1480]: (root) CMD (   cd /
&& run-p
rts --report /etc/cron.hourly)
Aug 31 17:04:18 vagrant-ubuntu-trusty-64 ansible-ping: Invoked with data=None
Aug 31 17:12:33 vagrant-ubuntu-trusty-64 ansible-ping: Invoked with data=None
Aug 31 17:14:07 vagrant-ubuntu-trusty-64 ansible-command: Invoked with executable
None shell=False args=uptime removes=None creates=None chdir=None
Aug 31 17:16:01 vagrant-ubuntu-trusty-64 ansible-command: Invoked with executable
None shell=False args=tail /var/log/messages removes=None creates=None chdir=None
Aug 31 17:17:01 vagrant-ubuntu-trusty-64 CRON[2091]: (root) CMD (   cd /
&& run-pa
rts --report /etc/cron.hourly)
Aug 31 17:17:09 vagrant-ubuntu-trusty-64 ansible-command: Invoked with /
executable=
N one shell=False args=tail /var/log/dmesg removes=None creates=None chdir=None
Aug 31 17:19:01 vagrant-ubuntu-trusty-64 ansible-command: Invoked with /
executable=
None shell=False args=tail /var/log/messages removes=None creates=None chdir=None
Aug 31 17:22:32 vagrant-ubuntu-trusty-64 ansible-command: Invoked with /
executable=
one shell=False args=tail /var/log/syslog removes=None creates=None chdir=None
----

We can see from this output that Ansible writes to the syslog as it runs.

You aren't just restricted to the `ping` and `command` modules when using the
`ansible` command-line tool: you can use any module that you like.((("apt module", "using with ansible command to install Nginx on Ubuntu")))((("ansible command", "using any module")))((("Nginx", "installing on Ubuntu"))) For example,
you can install Nginx on Ubuntu by using the following command:
[source,console]
----
$ ansible testserver -b -m apt -a name=nginx
----

[TIP]
====
If installing Nginx fails for you, you might need to update the package lists. To
tell Ansible to do the equivalent of +apt-get update+ before installing the
package, change the argument from +name=nginx+ to +"name=nginx update_cache=yes"+.

You can restart Nginx as follows:
[source,console]
----
$ ansible testserver -b -m service -a "name=nginx \
    state=restarted"
----
====

We need the +-b+ argument to become the root user because only root can install the Nginx package and restart services.((("test server for Ansible", startref="ix_testser")))((("servers", "setting up a server for testing", startref="ix_serversetup")))

=== Moving Forward

To recap, this introductory chapter covered the basic concepts of Ansible at a high level, including how it communicates with remote servers and how it
differs from other configuration management tools. You've also seen how to use
the `ansible` command-line tool to perform simple tasks on a single host.

However, using `ansible` to run commands against single hosts isn't terribly interesting.
The next chapter covers playbooks, where the real action is.

// vim: set syntax=asciidoc:
